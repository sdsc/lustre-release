diff -urp linux-3.6.6-3.fc18.el6.x86_64.orig/block/blk-core.c linux-3.6.6-3.fc18.el6.x86_64/block/blk-core.c
--- linux-3.6.6-3.fc18.el6.x86_64.orig/block/blk-core.c	2013-01-15 13:44:40.925175578 -0500
+++ linux-3.6.6-3.fc18.el6.x86_64/block/blk-core.c	2013-01-15 14:05:00.281174881 -0500
@@ -1606,6 +1606,8 @@ static inline bool should_fail_request(s
 
 #endif /* CONFIG_FAIL_MAKE_REQUEST */
 
+int dev_check_rdonly(struct block_device *bdev);
+
 /*
  * Check whether this bio extends beyond the end of the device.
  */
@@ -1668,6 +1670,12 @@ generic_make_request_checks(struct bio *
 		goto end_io;
 	}
 
+	/* this is cfs's dev_rdonly check */
+	if (bio_rw(bio) == WRITE && dev_check_rdonly(bio->bi_bdev)) {
+		err = 0;
+		goto end_io;
+	}
+
 	part = bio->bi_bdev->bd_part;
 	if (should_fail_request(part, bio->bi_size) ||
 	    should_fail_request(&part_to_disk(part)->part0,
@@ -3034,6 +3042,99 @@ void blk_finish_plug(struct blk_plug *pl
 }
 EXPORT_SYMBOL(blk_finish_plug);
 
+/*
+ * Debug code for turning block devices "read-only" (will discard writes
+ * silently).  This is for filesystem crash/recovery testing.
+ */
+struct deventry {
+	dev_t dev;
+	struct deventry *next;
+};
+
+static struct deventry *devlist = NULL;
+static spinlock_t devlock = __SPIN_LOCK_UNLOCKED(devlock);
+
+int dev_check_rdonly(struct block_device *bdev)
+{
+	struct deventry *cur;
+
+	if (!bdev)
+		return 0;
+
+	spin_lock(&devlock);
+	cur = devlist;
+	while(cur) {
+		if (bdev->bd_dev == cur->dev) {
+			spin_unlock(&devlock);
+			return 1;
+		}
+		cur = cur->next;
+	}
+	spin_unlock(&devlock);
+	return 0;
+}
+
+void dev_set_rdonly(struct block_device *bdev)
+{
+	struct deventry *newdev, *cur;
+
+	if (!bdev)
+		return;
+
+	newdev = kmalloc(sizeof(struct deventry), GFP_KERNEL);
+	if (!newdev)
+		return;
+
+	spin_lock(&devlock);
+	cur = devlist;
+	while(cur) {
+		if (bdev->bd_dev == cur->dev) {
+			spin_unlock(&devlock);
+			kfree(newdev);
+			return;
+		}
+		cur = cur->next;
+	}
+	newdev->dev = bdev->bd_dev;
+	newdev->next = devlist;
+	devlist = newdev;
+	spin_unlock(&devlock);
+	printk(KERN_WARNING "Turning device %s (%#x) read-only\n",
+		bdev->bd_disk ? bdev->bd_disk->disk_name : "", bdev->bd_dev);
+}
+
+void dev_clear_rdonly(struct block_device *bdev)
+{
+	struct deventry *cur, *last = NULL;
+
+	if (!bdev)
+		return;
+
+	spin_lock(&devlock);
+	cur = devlist;
+	while(cur) {
+		if (bdev->bd_dev == cur->dev) {
+			if (last)
+				last->next = cur->next;
+			else
+				devlist = cur->next;
+			spin_unlock(&devlock);
+			kfree(cur);
+			printk(KERN_WARNING "Removing read-only on %s (%#x)\n",
+				bdev->bd_disk ? bdev->bd_disk->disk_name :
+				"unknown block", bdev->bd_dev);
+			return;
+		}
+		last = cur;
+		cur = cur->next;
+	}
+	spin_unlock(&devlock);
+}
+
+EXPORT_SYMBOL(dev_set_rdonly);
+EXPORT_SYMBOL(dev_clear_rdonly);
+EXPORT_SYMBOL(dev_check_rdonly);
+
 int __init blk_dev_init(void)
 {
 	BUILD_BUG_ON(__REQ_NR_BITS > 8 *
diff -urp linux-3.6.6-3.fc18.el6.x86_64.orig/fs/block_dev.c linux-3.6.6-3.fc18.el6.x86_64/fs/block_dev.c
--- linux-3.6.6-3.fc18.el6.x86_64.orig/fs/block_dev.c	2012-09-30 19:47:46.000000000 -0400
+++ linux-3.6.6-3.fc18.el6.x86_64/fs/block_dev.c	2013-01-15 14:05:00.291174371 -0500
@@ -1484,6 +1484,7 @@ static int __blkdev_put(struct block_dev
 		if (bdev != bdev->bd_contains)
 			victim = bdev->bd_contains;
 		bdev->bd_contains = NULL;
+		dev_clear_rdonly(bdev);
 
 		put_disk(disk);
 		module_put(owner);
diff -urp linux-3.6.6-3.fc18.el6.x86_64.orig/include/linux/fs.h linux-3.6.6-3.fc18.el6.x86_64/include/linux/fs.h
--- linux-3.6.6-3.fc18.el6.x86_64.orig/include/linux/fs.h	2012-09-30 19:47:46.000000000 -0400
+++ linux-3.6.6-3.fc18.el6.x86_64/include/linux/fs.h	2013-01-15 14:05:00.299174916 -0500
@@ -2542,6 +2542,10 @@ extern void inode_sb_list_add(struct ino
 extern void submit_bio(int, struct bio *);
 extern int bdev_read_only(struct block_device *);
 #endif
+#define HAVE_CLEAR_RDONLY_ON_PUT
+extern void dev_set_rdonly(struct block_device *bdev);
+extern int dev_check_rdonly(struct block_device *bdev);
+extern void dev_clear_rdonly(struct block_device *bdev);
 extern int set_blocksize(struct block_device *, int);
 extern int sb_set_blocksize(struct super_block *, int);
 extern int sb_min_blocksize(struct super_block *, int);
