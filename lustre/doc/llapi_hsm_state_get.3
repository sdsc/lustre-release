.TH lustreapi 3 "2014 Jul 30" Lustre "Lustre Application Interface Library"
.SH NAME
llapi_hsm_state_get, llapi_hsm_state_get_fd \- get HSM state
information for a file on a Lustre filesystem
.SH SYNOPSIS
.nf
.B #include <lustre/lustreapi.h>
.sp
.BI "int llapi_hsm_state_get(const char *" path ", struct hsm_user_state *" hus ");"
.sp
.BI "int llapi_hsm_state_get_fd(int " fd ", struct hsm_user_state *" hus ");"
.sp
.fi
.SH DESCRIPTION
.LP
These functions return the HSM state flags and HSM archive ID for the
file referred to by
.IR path
or
.IR fd .
Information is returned in the
.I hus
argument which should already be allocated.

.nf
struct hsm_user_state {
	__u32	hus_states;
	__u32	hus_archive_id;
};
.fi
.TP 20
.I hus_states
Flag mask for different HSM states and policy hints. See
.I hsm_states
enum for full list.
.TP 20
.I hus_archive_id
External HSM archive ID associated with this file.
.LP

.nf
enum hsm_states {
	HS_EXISTS,
	HS_DIRTY,
	HS_RELEASED,
	HS_ARCHIVED,
	HS_NORELEASE,
	HS_NOARCHIVE,
	HS_LOST,
};
.fi

.TP 20
.I HS_EXISTS
The file has been assigned to an archive.
.TP
.I HS_DIRTY
The file content is not in sync with the HSM archive.  This flag is
set automatically when a file with HS_EXISTS set is changed, and can
be set explicitly by a user.
.TP
.I HS_RELEASED
The file content is not present in Lustre, and must be restored from
the HSM archive before the file can be accessed.  File must also be
HS_ARCHIVED state and not HS_DIRTY.
.TP
.I HS_ARCHIVED
An up-to-date copy of the file content exists in the HSM archive.
.TP
.I HS_NORELEASE
This flag indicates the file content should never be released. File
content will stay in Lustre even if a copy exists in HSM backend.
This can be set by a user.
.TP
.I HS_NOARCHIVE
File will not be archived. This might be used for a large temporary
file, for example. This can be set by a user.
.TP
.I HS_LOST
File content in the archive is not available, and file can not be
restored. If this file is also HS_RELEASED, then attempts to access
the file will fail.  This is can be set an administrator.

.SH RETURN VALUES
.LP
.B llapi_hsm_state_get(\|)
and
.B llapi_hsm_state_get_fd(\|)
return:
.TP
0
on success
.TP
-errno
on failure
.SH ERRORS
.TP 15
.SM ENOMEM
failed to allocate memory.
.TP 15
.SM ENAMETOOLONG
.I path
was too long.
.TP 15
.SM ENOENT
.I path
does not point to a file or a directory.
.TP 15
.SM ENOTTY
.I path
does not point to a Lustre filesystem.
.SH EXAMPLE
.nf
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>

#include <lustre/lustreapi.h>

int main(int argc, char **argv)
{
	struct hsm_user_state hus;
	int rc;

	if (argc < 2) {
		fprintf(stderr, "usage: prog FILEPATH\\n");
		exit(1);
	}

	rc = llapi_hsm_state_get(argv[1], &hus);
	if (rc) {
		fprintf(stderr, "can't get hsm state for %s: %s\\n",
			argv[1], strerror(errno = -rc));
		exit(rc);
	}

	if (hus.hus_states & HS_RELEASED)
		printf(" released");
	if (hus.hus_states & HS_EXISTS)
		printf(" exists");
	if (hus.hus_states & HS_ARCHIVED)
		printf(" archived");

	/* Display settable flags */
	if (hus.hus_states & HS_NORELEASE)
		printf(" never_release");
	if (hus.hus_states & HS_NOARCHIVE)
		printf(" never_archive");
	if (hus.hus_states & HS_DIRTY)
		printf(" dirty");
	if (hus.hus_states & HS_LOST)
		printf(" lost_from_hsm");

	if (hus.hus_archive_id != 0)
		printf(", archive_id:%d", hus.hus_archive_id);

	printf("\\n");

	exit(0);
}
.fi
.SH "SEE ALSO"
.BR lustre (7),
.BR lustreapi (7),
.BR llapi_hsm_state_set (3),
.BR llapi_hsm_state_set_fd (3),
.BR lfs-hsm (1)
