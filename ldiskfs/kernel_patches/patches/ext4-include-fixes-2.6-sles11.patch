diff -urpN linux-stage.orig/ext4-include-fixes-2.6-sles11.patch linux-stage/ext4-include-fixes-2.6-sles11.patch
--- linux-stage.orig/ext4-include-fixes-2.6-sles11.patch	1969-12-31 19:00:00.000000000 -0500
+++ linux-stage/ext4-include-fixes-2.6-sles11.patch	2011-06-13 11:29:38.205056000 -0400
@@ -0,0 +1,1212 @@
+diff -urpN linux-stage.orig/fs/ext4/balloc.c linux-stage/fs/ext4/balloc.c
+--- linux-stage.orig/fs/ext4/balloc.c	2011-06-13 11:17:46.514457000 -0400
++++ linux-stage/fs/ext4/balloc.c	2011-06-13 11:23:05.882771000 -0400
+@@ -97,7 +97,7 @@ unsigned ext4_init_block_bitmap(struct s
+ 		/* If checksum is bad mark all blocks used to prevent allocation
+ 		 * essentially implementing a per-group read-only flag. */
+ 		if (!ext4_group_desc_csum_verify(sbi, block_group, gdp)) {
+-			ext4_error(sb, __func__,
++			ext4_error(sb,
+ 				  "Checksum bad for group %u", block_group);
+ 			ext4_free_blks_set(sb, gdp, 0);
+ 			ext4_free_inodes_set(sb, gdp, 0);
+@@ -207,10 +207,8 @@ struct ext4_group_desc * ext4_get_group_
+ 	struct ext4_sb_info *sbi = EXT4_SB(sb);
+ 
+ 	if (block_group >= ngroups) {
+-		ext4_error(sb, "ext4_get_group_desc",
+-			   "block_group >= groups_count - "
+-			   "block_group = %u, groups_count = %u",
+-			   block_group, ngroups);
++		ext4_error(sb, "block_group >= groups_count - block_group = %u,"
++			   " groups_count = %u", block_group, ngroups);
+ 
+ 		return NULL;
+ 	}
+@@ -218,8 +216,7 @@ struct ext4_group_desc * ext4_get_group_
+ 	group_desc = block_group >> EXT4_DESC_PER_BLOCK_BITS(sb);
+ 	offset = block_group & (EXT4_DESC_PER_BLOCK(sb) - 1);
+ 	if (!sbi->s_group_desc[group_desc]) {
+-		ext4_error(sb, "ext4_get_group_desc",
+-			   "Group descriptor not loaded - "
++		ext4_error(sb, "Group descriptor not loaded - "
+ 			   "block_group = %u, group_desc = %u, desc = %u",
+ 			   block_group, group_desc, offset);
+ 		return NULL;
+@@ -280,7 +277,7 @@ static int ext4_valid_block_bitmap(struc
+ 		return 1;
+ 
+ err_out:
+-	ext4_error(sb, __func__,
++	ext4_error(sb,
+ 			"Invalid block bitmap - "
+ 			"block_group = %d, block = %llu",
+ 			block_group, bitmap_blk);
+@@ -309,7 +306,7 @@ ext4_read_block_bitmap(struct super_bloc
+ 	bitmap_blk = ext4_block_bitmap(sb, desc);
+ 	bh = sb_getblk(sb, bitmap_blk);
+ 	if (unlikely(!bh)) {
+-		ext4_error(sb, __func__,
++		ext4_error(sb,
+ 			    "Cannot read block bitmap - "
+ 			    "block_group = %u, block_bitmap = %llu",
+ 			    block_group, bitmap_blk);
+@@ -352,7 +349,7 @@ ext4_read_block_bitmap(struct super_bloc
+ 	set_bitmap_uptodate(bh);
+ 	if (bh_submit_read(bh) < 0) {
+ 		put_bh(bh);
+-		ext4_error(sb, __func__,
++		ext4_error(sb,
+ 			    "Cannot read block bitmap - "
+ 			    "block_group = %u, block_bitmap = %llu",
+ 			    block_group, bitmap_blk);
+@@ -417,7 +414,7 @@ void ext4_add_groupblocks(handle_t *hand
+ 	    in_range(block, ext4_inode_table(sb, desc), sbi->s_itb_per_group) ||
+ 	    in_range(block + count - 1, ext4_inode_table(sb, desc),
+ 		     sbi->s_itb_per_group)) {
+-		ext4_error(sb, __func__,
++		ext4_error(sb,
+ 			   "Adding blocks in system zones - "
+ 			   "Block = %llu, count = %lu",
+ 			   block, count);
+@@ -451,7 +448,7 @@ void ext4_add_groupblocks(handle_t *hand
+ 		BUFFER_TRACE(bitmap_bh, "clear bit");
+ 		if (!ext4_clear_bit_atomic(ext4_group_lock_ptr(sb, block_group),
+ 						bit + i, bitmap_bh->b_data)) {
+-			ext4_error(sb, __func__,
++			ext4_error(sb,
+ 				   "bit already cleared for block %llu",
+ 				   (ext4_fsblk_t)(block + i));
+ 			BUFFER_TRACE(bitmap_bh, "bit already cleared");
+diff -urpN linux-stage.orig/fs/ext4/dir.c linux-stage/fs/ext4/dir.c
+--- linux-stage.orig/fs/ext4/dir.c	2011-06-13 11:17:46.251720000 -0400
++++ linux-stage/fs/ext4/dir.c	2011-06-13 11:23:05.887774000 -0400
+@@ -83,7 +83,7 @@ int ext4_check_dir_entry(const char *fun
+ 		error_msg = "inode out of bounds";
+ 
+ 	if (error_msg != NULL)
+-		ext4_error(dir->i_sb, function,
++		ext4_error(dir->i_sb,
+ 			"bad entry in directory #%lu: %s - block=%llu"
+ 			"offset=%u(%u), inode=%u, rec_len=%d, name_len=%d",
+ 			dir->i_ino, error_msg,
+@@ -152,7 +152,7 @@ static int ext4_readdir(struct file *fil
+ 		 */
+ 		if (!bh) {
+ 			if (!dir_has_error) {
+-				ext4_error(sb, __func__, "directory #%lu "
++				ext4_error(sb, "directory #%lu "
+ 					   "contains a hole at offset %Lu",
+ 					   inode->i_ino,
+ 					   (unsigned long long) filp->f_pos);
+diff -urpN linux-stage.orig/fs/ext4/ext4.h linux-stage/fs/ext4/ext4.h
+--- linux-stage.orig/fs/ext4/ext4.h	2011-06-13 11:17:46.603372000 -0400
++++ linux-stage/fs/ext4/ext4.h	2011-06-13 11:27:41.696679000 -0400
+@@ -23,6 +23,7 @@
+ #include <linux/quota.h>
+ #include <linux/rwsem.h>
+ #include <linux/rbtree.h>
++#include <linux/kernel.h>
+ #include <linux/seqlock.h>
+ #include <linux/mutex.h>
+ #include <linux/timer.h>
+@@ -1526,6 +1527,8 @@ extern int ext4_mb_add_groupinfo(struct 
+ extern int ext4_mb_get_buddy_cache_lock(struct super_block *, ext4_group_t);
+ extern void ext4_mb_put_buddy_cache_lock(struct super_block *,
+ 						ext4_group_t, int);
++extern int ext4_trim_fs(struct super_block *, struct fstrim_range *);
++
+ /* inode.c */
+ int ext4_forget(handle_t *handle, int is_metadata, struct inode *inode,
+ 		struct buffer_head *bh, ext4_fsblk_t blocknr);
+@@ -1586,13 +1589,15 @@ extern int ext4_group_extend(struct supe
+ 				ext4_fsblk_t n_blocks_count);
+ 
+ /* super.c */
+-extern void ext4_error(struct super_block *, const char *, const char *, ...)
++extern void __ext4_error(struct super_block *, const char *, const char *, ...)
+ 	__attribute__ ((format (printf, 3, 4)));
++#define ext4_error(sb, message...)	__ext4_error(sb, __func__, ## message)
+ extern void __ext4_std_error(struct super_block *, const char *, int);
+ extern void ext4_abort(struct super_block *, const char *, const char *, ...)
+ 	__attribute__ ((format (printf, 3, 4)));
+-extern void ext4_warning(struct super_block *, const char *, const char *, ...)
++extern void __ext4_warning(struct super_block *, const char *, const char *, ...)
+ 	__attribute__ ((format (printf, 3, 4)));
++#define ext4_warning(sb, message...)	__ext4_warning(sb, __func__, ## message)
+ extern void ext4_msg(struct super_block *, const char *, const char *, ...)
+ 	__attribute__ ((format (printf, 3, 4)));
+ extern void ext4_grp_locked_error(struct super_block *, ext4_group_t,
+diff -urpN linux-stage.orig/fs/ext4/ext4_jbd2.c linux-stage/fs/ext4/ext4_jbd2.c
+--- linux-stage.orig/fs/ext4/ext4_jbd2.c	2011-06-13 11:17:46.253719000 -0400
++++ linux-stage/fs/ext4/ext4_jbd2.c	2011-06-13 11:23:05.900755000 -0400
+@@ -96,7 +96,7 @@ int __ext4_handle_dirty_metadata(const c
+ 		if (inode && inode_needs_sync(inode)) {
+ 			sync_dirty_buffer(bh);
+ 			if (buffer_req(bh) && !buffer_uptodate(bh)) {
+-				ext4_error(inode->i_sb, __func__,
++				ext4_error(inode->i_sb,
+ 					   "IO error syncing inode, "
+ 					   "inode=%lu, block=%llu",
+ 					   inode->i_ino,
+diff -urpN linux-stage.orig/fs/ext4/extents.c linux-stage/fs/ext4/extents.c
+--- linux-stage.orig/fs/ext4/extents.c	2011-06-13 11:17:46.567406000 -0400
++++ linux-stage/fs/ext4/extents.c	2011-06-13 11:23:05.910746000 -0400
+@@ -437,7 +437,7 @@ static int __ext4_ext_check(const char *
+ 	return 0;
+ 
+ corrupted:
+-	ext4_error(inode->i_sb, function,
++	ext4_error(inode->i_sb,
+ 			"bad header/extent in inode #%lu: %s - magic %x, "
+ 			"entries %u, max %u(%u), depth %u(%u)",
+ 			inode->i_ino, error_msg, le16_to_cpu(eh->eh_magic),
+@@ -1534,7 +1534,7 @@ int ext4_ext_try_to_merge(struct inode *
+ 		merge_done = 1;
+ 		WARN_ON(eh->eh_entries == 0);
+ 		if (!eh->eh_entries)
+-			ext4_error(inode->i_sb, "ext4_ext_try_to_merge",
++			ext4_error(inode->i_sb,
+ 			   "inode#%lu, eh->eh_entries = 0!", inode->i_ino);
+ 	}
+ 
+@@ -3284,7 +3284,7 @@ int ext4_ext_get_blocks(handle_t *handle
+ 	 * this is why assert can't be put in ext4_ext_find_extent()
+ 	 */
+ 	if (path[depth].p_ext == NULL && depth != 0) {
+-		ext4_error(inode->i_sb, __func__, "bad extent address "
++		ext4_error(inode->i_sb, "bad extent address "
+ 			   "inode: %lu, iblock: %lu, depth: %d",
+ 			   inode->i_ino, (unsigned long) iblock, depth);
+ 		err = -EIO;
+@@ -3415,7 +3415,7 @@ int ext4_ext_get_blocks(handle_t *handle
+ 
+ 	if (unlikely(ext4_test_inode_flag(inode, EXT4_INODE_EOFBLOCKS))) {
+ 		if (unlikely(!eh->eh_entries)) {
+-			ext4_error(inode->i_sb, __func__,
++			ext4_error(inode->i_sb,
+ 				   "inode#%lu, eh->eh_entries = 0 and "
+ 				   "EOFBLOCKS_FL set", inode->i_ino);
+ 			err = -EIO;
+diff -urpN linux-stage.orig/fs/ext4/ialloc.c linux-stage/fs/ext4/ialloc.c
+--- linux-stage.orig/fs/ext4/ialloc.c	2011-06-13 11:17:46.594379000 -0400
++++ linux-stage/fs/ext4/ialloc.c	2011-06-13 11:23:05.917735000 -0400
+@@ -76,7 +76,7 @@ unsigned ext4_init_inode_bitmap(struct s
+ 	/* If checksum is bad mark all blocks and inodes use to prevent
+ 	 * allocation, essentially implementing a per-group read-only flag. */
+ 	if (!ext4_group_desc_csum_verify(sbi, block_group, gdp)) {
+-		ext4_error(sb, __func__, "Checksum bad for group %u",
++		ext4_error(sb, "Checksum bad for group %u",
+ 			   block_group);
+ 		ext4_free_blks_set(sb, gdp, 0);
+ 		ext4_free_inodes_set(sb, gdp, 0);
+@@ -111,7 +111,7 @@ ext4_read_inode_bitmap(struct super_bloc
+ 	bitmap_blk = ext4_inode_bitmap(sb, desc);
+ 	bh = sb_getblk(sb, bitmap_blk);
+ 	if (unlikely(!bh)) {
+-		ext4_error(sb, __func__,
++		ext4_error(sb,
+ 			    "Cannot read inode bitmap - "
+ 			    "block_group = %u, inode_bitmap = %llu",
+ 			    block_group, bitmap_blk);
+@@ -153,7 +153,7 @@ ext4_read_inode_bitmap(struct super_bloc
+ 	set_bitmap_uptodate(bh);
+ 	if (bh_submit_read(bh) < 0) {
+ 		put_bh(bh);
+-		ext4_error(sb, __func__,
++		ext4_error(sb,
+ 			    "Cannot read inode bitmap - "
+ 			    "block_group = %u, inode_bitmap = %llu",
+ 			    block_group, bitmap_blk);
+@@ -230,8 +230,7 @@ void ext4_free_inode(handle_t *handle, s
+ 
+ 	es = EXT4_SB(sb)->s_es;
+ 	if (ino < EXT4_FIRST_INO(sb) || ino > le32_to_cpu(es->s_inodes_count)) {
+-		ext4_error(sb, "ext4_free_inode",
+-			   "reserved or nonexistent inode %lu", ino);
++		ext4_error(sb, "reserved or nonexistent inode %lu", ino);
+ 		goto error_return;
+ 	}
+ 	block_group = (ino - 1) / EXT4_INODES_PER_GROUP(sb);
+@@ -286,11 +285,10 @@ out:
+ 			fatal = err;
+ 		sb->s_dirt = 1;
+ 	} else
+-		ext4_error(sb, "ext4_free_inode",
+-			   "bit already cleared for inode %lu", ino);
++		ext4_error(sb, "bit already cleared for inode %lu", ino);
+ 
+ error_return:
+-	brelse(bitmap_bh);
++	brelse(bitmap_bh); 
+ 	ext4_std_error(sb, fatal);
+ }
+ 
+@@ -730,7 +728,7 @@ static int ext4_claim_inode(struct super
+ 	if ((group == 0 && ino < EXT4_FIRST_INO(sb)) ||
+ 			ino > EXT4_INODES_PER_GROUP(sb)) {
+ 		ext4_unlock_group(sb, group);
+-		ext4_error(sb, __func__,
++		ext4_error(sb,
+ 			   "reserved inode or inode > inodes count - "
+ 			   "block_group = %u, inode=%lu", group,
+ 			   ino + group * EXT4_INODES_PER_GROUP(sb));
+@@ -1094,7 +1092,7 @@ struct inode *ext4_orphan_get(struct sup
+ 
+ 	/* Error cases - e2fsck has already cleaned up for us */
+ 	if (ino > max_ino) {
+-		ext4_warning(sb, __func__,
++		ext4_warning(sb,
+ 			     "bad orphan ino %lu!  e2fsck was run?", ino);
+ 		goto error;
+ 	}
+@@ -1103,7 +1101,7 @@ struct inode *ext4_orphan_get(struct sup
+ 	bit = (ino - 1) % EXT4_INODES_PER_GROUP(sb);
+ 	bitmap_bh = ext4_read_inode_bitmap(sb, block_group);
+ 	if (!bitmap_bh) {
+-		ext4_warning(sb, __func__,
++		ext4_warning(sb,
+ 			     "inode bitmap error for orphan %lu", ino);
+ 		goto error;
+ 	}
+@@ -1136,7 +1134,7 @@ iget_failed:
+ 	err = PTR_ERR(inode);
+ 	inode = NULL;
+ bad_orphan:
+-	ext4_warning(sb, __func__,
++	ext4_warning(sb,
+ 		     "bad orphan inode %lu!  e2fsck was run?", ino);
+ 	printk(KERN_NOTICE "ext4_test_bit(bit=%d, block=%llu) = %d\n",
+ 	       bit, (unsigned long long)bitmap_bh->b_blocknr,
+diff -urpN linux-stage.orig/fs/ext4/inode.c linux-stage/fs/ext4/inode.c
+--- linux-stage.orig/fs/ext4/inode.c	2011-06-13 11:17:46.586385000 -0400
++++ linux-stage/fs/ext4/inode.c	2011-06-13 11:23:05.930726000 -0400
+@@ -246,7 +246,7 @@ void ext4_delete_inode(struct inode *ino
+ 	inode->i_size = 0;
+ 	err = ext4_mark_inode_dirty(handle, inode);
+ 	if (err) {
+-		ext4_warning(inode->i_sb, __func__,
++		ext4_warning(inode->i_sb,
+ 			     "couldn't mark inode dirty (err %d)", err);
+ 		goto stop_handle;
+ 	}
+@@ -264,7 +264,7 @@ void ext4_delete_inode(struct inode *ino
+ 		if (err > 0)
+ 			err = ext4_journal_restart(handle, 3);
+ 		if (err != 0) {
+-			ext4_warning(inode->i_sb, __func__,
++			ext4_warning(inode->i_sb,
+ 				     "couldn't extend journal (err %d)", err);
+ 		stop_handle:
+ 			ext4_journal_stop(handle);
+@@ -375,8 +375,7 @@ static int ext4_block_to_path(struct ino
+ 		offsets[n++] = i_block & (ptrs - 1);
+ 		final = ptrs;
+ 	} else {
+-		ext4_warning(inode->i_sb, "ext4_block_to_path",
+-			     "block %lu > max in inode %lu",
++		ext4_warning(inode->i_sb, "block %lu > max in inode %lu",
+ 			     i_block + direct_blocks +
+ 			     indirect_blocks + double_blocks, inode->i_ino);
+ 	}
+@@ -396,7 +395,7 @@ static int __ext4_check_blockref(const c
+ 		if (blk &&
+ 		    unlikely(!ext4_data_block_valid(EXT4_SB(inode->i_sb),
+ 						    blk, 1))) {
+-			ext4_error(inode->i_sb, function,
++			ext4_error(inode->i_sb,
+ 				   "invalid block reference %u "
+ 				   "in inode #%lu", blk, inode->i_ino);
+ 			return -EIO;
+@@ -1167,7 +1166,7 @@ static int check_block_validity(struct i
+ 				sector_t logical, sector_t phys, int len)
+ {
+ 	if (!ext4_data_block_valid(EXT4_SB(inode->i_sb), phys, len)) {
+-		ext4_error(inode->i_sb, msg,
++		ext4_error(inode->i_sb,
+ 			   "inode #%lu logical block %llu mapped to %llu "
+ 			   "(size %d)", inode->i_ino,
+ 			   (unsigned long long) logical,
+@@ -4312,7 +4311,7 @@ static void ext4_free_data(handle_t *han
+ 		if ((EXT4_JOURNAL(inode) == NULL) || bh2jh(this_bh))
+ 			ext4_handle_dirty_metadata(handle, inode, this_bh);
+ 		else
+-			ext4_error(inode->i_sb, __func__,
++			ext4_error(inode->i_sb,
+ 				   "circular indirect block detected, "
+ 				   "inode=%lu, block=%llu",
+ 				   inode->i_ino,
+@@ -4360,7 +4359,7 @@ static void ext4_free_branches(handle_t 
+ 			 * (should be rare).
+ 			 */
+ 			if (!bh) {
+-				ext4_error(inode->i_sb, "ext4_free_branches",
++				ext4_error(inode->i_sb,
+ 					   "Read failure, inode=%lu, block=%llu",
+ 					   inode->i_ino, nr);
+ 				continue;
+@@ -4676,9 +4675,8 @@ static int __ext4_get_inode_loc(struct i
+ 
+ 	bh = sb_getblk(sb, block);
+ 	if (!bh) {
+-		ext4_error(sb, "ext4_get_inode_loc", "unable to read "
+-			   "inode block - inode=%lu, block=%llu",
+-			   inode->i_ino, block);
++		ext4_error(sb, "unable to read inode block - "
++			   "inode=%lu, block=%llu", inode->i_ino, block);
+ 		return -EIO;
+ 	}
+ 	if (!buffer_uptodate(bh)) {
+@@ -4776,7 +4774,7 @@ make_io:
+ 		submit_bh(READ_META, bh);
+ 		wait_on_buffer(bh);
+ 		if (!buffer_uptodate(bh)) {
+-			ext4_error(sb, __func__,
++			ext4_error(sb,
+ 				   "unable to read inode block - inode=%lu, "
+ 				   "block=%llu", inode->i_ino, block);
+ 			brelse(bh);
+@@ -4989,7 +4987,7 @@ struct inode *ext4_iget(struct super_blo
+ 	ret = 0;
+ 	if (ei->i_file_acl &&
+ 	    !ext4_data_block_valid(EXT4_SB(sb), ei->i_file_acl, 1)) {
+-		ext4_error(sb, __func__,
++		ext4_error(sb,
+ 			   "bad extended attribute block %llu in inode #%lu",
+ 			   ei->i_file_acl, inode->i_ino);
+ 		ret = -EIO;
+@@ -5036,7 +5034,7 @@ struct inode *ext4_iget(struct super_blo
+ 			   new_decode_dev(le32_to_cpu(raw_inode->i_block[1])));
+ 	} else {
+ 		ret = -EIO;
+-		ext4_error(inode->i_sb, __func__,
++		ext4_error(inode->i_sb,
+ 			   "bogus i_mode (%o) for inode=%lu",
+ 			   inode->i_mode, inode->i_ino);
+ 		goto bad_inode;
+@@ -5276,7 +5274,7 @@ int ext4_write_inode(struct inode *inode
+ 		if (wait)
+ 			sync_dirty_buffer(iloc.bh);
+ 		if (buffer_req(iloc.bh) && !buffer_uptodate(iloc.bh)) {
+-			ext4_error(inode->i_sb, __func__,
++			ext4_error(inode->i_sb,
+ 				   "IO error syncing inode, "
+ 				   "inode=%lu, block=%llu",
+ 				   inode->i_ino,
+@@ -5698,7 +5696,7 @@ int ext4_mark_inode_dirty(handle_t *hand
+ 						     EXT4_STATE_NO_EXPAND);
+ 				if (mnt_count !=
+ 					le16_to_cpu(sbi->s_es->s_mnt_count)) {
+-					ext4_warning(inode->i_sb, __func__,
++					ext4_warning(inode->i_sb,
+ 					"Unable to expand inode %lu. Delete"
+ 					" some EAs or run e2fsck.",
+ 					inode->i_ino);
+diff -urpN linux-stage.orig/fs/ext4/mballoc.c linux-stage/fs/ext4/mballoc.c
+--- linux-stage.orig/fs/ext4/mballoc.c	2011-06-13 11:17:46.291682000 -0400
++++ linux-stage/fs/ext4/mballoc.c	2011-06-13 11:23:05.942710000 -0400
+@@ -1860,7 +1860,6 @@ void ext4_mb_scan_aligned(struct ext4_al
+ 	}
+ }
+ 
+-/* This is now called BEFORE we load the buddy bitmap. */
+ static int ext4_mb_good_group(struct ext4_allocation_context *ac,
+ 				ext4_group_t group, int cr)
+ {
+@@ -2160,6 +2159,11 @@ static void *ext4_mb_seq_groups_next(str
+ 	return (void *) ((unsigned long) group);
+ }
+ 
++static inline void ext4_mb_release_desc(struct ext4_buddy *e4b)
++{
++	ext4_mb_unload_buddy(e4b);
++}
++
+ static int ext4_mb_seq_groups_show(struct seq_file *seq, void *v)
+ {
+ 	struct super_block *sb = seq->private;
+@@ -2191,7 +2195,7 @@ static int ext4_mb_seq_groups_show(struc
+ 	ext4_lock_group(sb, group);
+ 	memcpy(&sg, ext4_get_group_info(sb, group), i);
+ 	ext4_unlock_group(sb, group);
+-	ext4_mb_unload_buddy(&e4b);
++	ext4_mb_release_desc(&e4b);
+ 
+ 	seq_printf(seq, "#%-5u: %-5u %-5u %-5u [", group, sg.info.bb_free,
+ 			sg.info.bb_fragments, sg.info.bb_first_free);
+@@ -2590,7 +2594,7 @@ static void release_blocks_on_commit(jou
+ 					entry->count);
+ 			ret = sb_issue_discard(sb, discard_block, entry->count);
+ 			if (ret == EOPNOTSUPP) {
+-				ext4_warning(sb, __func__,
++				ext4_warning(sb,
+ 					"discard not supported, disabling");
+ 				clear_opt(EXT4_SB(sb)->s_mount_opt, DISCARD);
+ 			}
+@@ -2755,7 +2759,7 @@ ext4_mb_mark_diskspace_used(struct ext4_
+ 
+ 	len = ac->ac_b_ex.fe_len;
+ 	if (!ext4_data_block_valid(sbi, block, len)) {
+-		ext4_error(sb, __func__,
++		ext4_error(sb,
+ 			   "Allocating blocks %llu-%llu which overlap "
+ 			   "fs metadata\n", block, block+len);
+ 		/* File system mounted not to panic on error
+@@ -3669,14 +3673,14 @@ ext4_mb_discard_group_preallocations(str
+ 
+ 	bitmap_bh = ext4_read_block_bitmap(sb, group);
+ 	if (bitmap_bh == NULL) {
+-		ext4_error(sb, __func__, "Error in reading block "
++		ext4_error(sb, "Error in reading block "
+ 				"bitmap for %u", group);
+ 		return 0;
+ 	}
+ 
+ 	err = ext4_mb_load_buddy(sb, group, &e4b);
+ 	if (err) {
+-		ext4_error(sb, __func__, "Error in loading buddy "
++		ext4_error(sb, "Error in loading buddy "
+ 				"information for %u", group);
+ 		put_bh(bitmap_bh);
+ 		return 0;
+@@ -3850,14 +3854,14 @@ repeat:
+ 
+ 		err = ext4_mb_load_buddy(sb, group, &e4b);
+ 		if (err) {
+-			ext4_error(sb, __func__, "Error in loading buddy "
+-					"information for %u", group);
++			ext4_error(sb, "Error in loading buddy information for %u",
++					group);
+ 			continue;
+ 		}
+ 
+ 		bitmap_bh = ext4_read_block_bitmap(sb, group);
+ 		if (bitmap_bh == NULL) {
+-			ext4_error(sb, __func__, "Error in reading block "
++			ext4_error(sb, "Error in reading block "
+ 					"bitmap for %u", group);
+ 			ext4_mb_unload_buddy(&e4b);
+ 			continue;
+@@ -4123,7 +4127,7 @@ ext4_mb_discard_lg_preallocations(struct
+ 
+ 		ext4_get_group_no_and_offset(sb, pa->pa_pstart, &group, NULL);
+ 		if (ext4_mb_load_buddy(sb, group, &e4b)) {
+-			ext4_error(sb, __func__, "Error in loading buddy "
++			ext4_error(sb, "Error in loading buddy "
+ 					"information for %u", group);
+ 			continue;
+ 		}
+@@ -4514,7 +4518,7 @@ void ext4_mb_free_blocks(handle_t *handl
+ 	if (block < le32_to_cpu(es->s_first_data_block) ||
+ 	    block + count < block ||
+ 	    block + count > ext4_blocks_count(es)) {
+-		ext4_error(sb, __func__,
++		ext4_error(sb,
+ 			    "Freeing blocks not in datazone - "
+ 			    "block = %llu, count = %lu", block, count);
+ 		goto error_return;
+@@ -4559,7 +4563,7 @@ do_more:
+ 	    in_range(block + count - 1, ext4_inode_table(sb, gdp),
+ 		      EXT4_SB(sb)->s_itb_per_group)) {
+ 
+-		ext4_error(sb, __func__,
++		ext4_error(sb,
+ 			   "Freeing blocks in system zone - "
+ 			   "Block = %llu, count = %lu", block, count);
+ 		/* err = 0. ext4_std_error should be a no op */
+diff -urpN linux-stage.orig/fs/ext4/move_extent.c linux-stage/fs/ext4/move_extent.c
+--- linux-stage.orig/fs/ext4/move_extent.c	2011-06-13 11:17:46.297674000 -0400
++++ linux-stage/fs/ext4/move_extent.c	2011-06-13 11:23:05.955698000 -0400
+@@ -152,12 +152,12 @@ mext_check_null_inode(struct inode *inod
+ 	int ret = 0;
+ 
+ 	if (inode1 == NULL) {
+-		ext4_error(inode2->i_sb, function,
++		ext4_error(inode2->i_sb,
+ 			"Both inodes should not be NULL: "
+ 			"inode1 NULL inode2 %lu", inode2->i_ino);
+ 		ret = -EIO;
+ 	} else if (inode2 == NULL) {
+-		ext4_error(inode1->i_sb, function,
++		ext4_error(inode1->i_sb,
+ 			"Both inodes should not be NULL: "
+ 			"inode1 %lu inode2 NULL", inode1->i_ino);
+ 		ret = -EIO;
+@@ -528,7 +528,7 @@ mext_leaf_block(handle_t *handle, struct
+ 	 * new_ext       |-------|
+ 	 */
+ 	if (le32_to_cpu(oext->ee_block) + oext_alen - 1 < new_ext_end) {
+-		ext4_error(orig_inode->i_sb, __func__,
++		ext4_error(orig_inode->i_sb,
+ 			"new_ext_end(%u) should be less than or equal to "
+ 			"oext->ee_block(%u) + oext_alen(%d) - 1",
+ 			new_ext_end, le32_to_cpu(oext->ee_block),
+@@ -691,12 +691,12 @@ mext_replace_branches(handle_t *handle, 
+ 	while (1) {
+ 		/* The extent for donor must be found. */
+ 		if (!dext) {
+-			ext4_error(donor_inode->i_sb, __func__,
++			ext4_error(donor_inode->i_sb,
+ 				   "The extent for donor must be found");
+ 			*err = -EIO;
+ 			goto out;
+ 		} else if (donor_off != le32_to_cpu(tmp_dext.ee_block)) {
+-			ext4_error(donor_inode->i_sb, __func__,
++			ext4_error(donor_inode->i_sb,
+ 				"Donor offset(%u) and the first block of donor "
+ 				"extent(%u) should be equal",
+ 				donor_off,
+@@ -1356,7 +1356,7 @@ ext4_move_extents(struct file *o_filp, s
+ 			if (ret1 < 0)
+ 				break;
+ 			if (*moved_len > len) {
+-				ext4_error(orig_inode->i_sb, __func__,
++				ext4_error(orig_inode->i_sb,
+ 					"We replaced blocks too much! "
+ 					"sum of replaced: %llu requested: %llu",
+ 					*moved_len, len);
+diff -urpN linux-stage.orig/fs/ext4/namei.c linux-stage/fs/ext4/namei.c
+--- linux-stage.orig/fs/ext4/namei.c	2011-06-13 11:17:46.439536000 -0400
++++ linux-stage/fs/ext4/namei.c	2011-06-13 11:23:05.964690000 -0400
+@@ -394,8 +394,7 @@ dx_probe(const struct qstr *d_name, stru
+ 	if (root->info.hash_version != DX_HASH_TEA &&
+ 	    root->info.hash_version != DX_HASH_HALF_MD4 &&
+ 	    root->info.hash_version != DX_HASH_LEGACY) {
+-		ext4_warning(dir->i_sb, __func__,
+-			     "Unrecognised inode hash code %d",
++		ext4_warning(dir->i_sb, "Unrecognised inode hash code %d",
+ 			     root->info.hash_version);
+ 		brelse(bh);
+ 		*err = ERR_BAD_DX_DIR;
+@@ -410,8 +409,7 @@ dx_probe(const struct qstr *d_name, stru
+ 	hash = hinfo->hash;
+ 
+ 	if (root->info.unused_flags & 1) {
+-		ext4_warning(dir->i_sb, __func__,
+-			     "Unimplemented inode hash flags: %#06x",
++		ext4_warning(dir->i_sb, "Unimplemented inode hash flags: %#06x",
+ 			     root->info.unused_flags);
+ 		brelse(bh);
+ 		*err = ERR_BAD_DX_DIR;
+@@ -419,8 +417,7 @@ dx_probe(const struct qstr *d_name, stru
+ 	}
+ 
+ 	if ((indirect = root->info.indirect_levels) > 1) {
+-		ext4_warning(dir->i_sb, __func__,
+-			     "Unimplemented inode hash depth: %#06x",
++		ext4_warning(dir->i_sb, "Unimplemented inode hash depth: %#06x",
+ 			     root->info.indirect_levels);
+ 		brelse(bh);
+ 		*err = ERR_BAD_DX_DIR;
+@@ -432,8 +429,7 @@ dx_probe(const struct qstr *d_name, stru
+ 
+ 	if (dx_get_limit(entries) != dx_root_limit(dir,
+ 						   root->info.info_length)) {
+-		ext4_warning(dir->i_sb, __func__,
+-			     "dx entry: limit != root limit");
++		ext4_warning(dir->i_sb, "dx entry: limit != root limit");
+ 		brelse(bh);
+ 		*err = ERR_BAD_DX_DIR;
+ 		goto fail;
+@@ -444,7 +440,7 @@ dx_probe(const struct qstr *d_name, stru
+ 	{
+ 		count = dx_get_count(entries);
+ 		if (!count || count > dx_get_limit(entries)) {
+-			ext4_warning(dir->i_sb, __func__,
++			ext4_warning(dir->i_sb,
+ 				     "dx entry: no count or count > limit");
+ 			brelse(bh);
+ 			*err = ERR_BAD_DX_DIR;
+@@ -489,7 +485,7 @@ dx_probe(const struct qstr *d_name, stru
+ 			goto fail2;
+ 		at = entries = ((struct dx_node *) bh->b_data)->entries;
+ 		if (dx_get_limit(entries) != dx_node_limit (dir)) {
+-			ext4_warning(dir->i_sb, __func__,
++			ext4_warning(dir->i_sb,
+ 				     "dx entry: limit != node limit");
+ 			brelse(bh);
+ 			*err = ERR_BAD_DX_DIR;
+@@ -505,7 +501,7 @@ fail2:
+ 	}
+ fail:
+ 	if (*err == ERR_BAD_DX_DIR)
+-		ext4_warning(dir->i_sb, __func__,
++		ext4_warning(dir->i_sb,
+ 			     "Corrupt dir inode %ld, running e2fsck is "
+ 			     "recommended.", dir->i_ino);
+ 	return NULL;
+@@ -958,7 +954,7 @@ restart:
+ 		wait_on_buffer(bh);
+ 		if (!buffer_uptodate(bh)) {
+ 			/* read error, skip block & hope for the best */
+-			ext4_error(sb, __func__, "reading directory #%lu "
++			ext4_error(sb, "reading directory #%lu "
+ 				   "offset %lu", dir->i_ino,
+ 				   (unsigned long)block);
+ 			brelse(bh);
+@@ -1052,7 +1048,7 @@ static struct buffer_head * ext4_dx_find
+ 		retval = ext4_htree_next_block(dir, hash, frame,
+ 					       frames, NULL);
+ 		if (retval < 0) {
+-			ext4_warning(sb, __func__,
++			ext4_warning(sb,
+ 			     "error reading index page in directory #%lu",
+ 			     dir->i_ino);
+ 			*err = retval;
+@@ -1082,14 +1078,13 @@ static struct dentry *ext4_lookup(struct
+ 		__u32 ino = le32_to_cpu(de->inode);
+ 		brelse(bh);
+ 		if (!ext4_valid_inum(dir->i_sb, ino)) {
+-			ext4_error(dir->i_sb, "ext4_lookup",
+-				   "bad inode number: %u", ino);
++			ext4_error(dir->i_sb, "bad inode number: %u", ino);
+ 			return ERR_PTR(-EIO);
+ 		}
+ 		inode = ext4_iget(dir->i_sb, ino);
+ 		if (unlikely(IS_ERR(inode))) {
+ 			if (PTR_ERR(inode) == -ESTALE) {
+-				ext4_error(dir->i_sb, __func__,
++				ext4_error(dir->i_sb,
+ 						"deleted inode referenced: %u",
+ 						ino);
+ 				return ERR_PTR(-EIO);
+@@ -1121,7 +1116,7 @@ struct dentry *ext4_get_parent(struct de
+ 	brelse(bh);
+ 
+ 	if (!ext4_valid_inum(child->d_inode->i_sb, ino)) {
+-		ext4_error(child->d_inode->i_sb, "ext4_get_parent",
++		ext4_error(child->d_inode->i_sb,
+ 			   "bad inode number: %u", ino);
+ 		return ERR_PTR(-EIO);
+ 	}
+@@ -1421,7 +1416,7 @@ static int make_indexed_dir(handle_t *ha
+ 	de = (struct ext4_dir_entry_2 *)((char *)fde +
+ 		ext4_rec_len_from_disk(fde->rec_len, blocksize));
+ 	if ((char *) de >= (((char *) root) + blocksize)) {
+-		ext4_error(dir->i_sb, __func__,
++		ext4_error(dir->i_sb,
+ 			   "invalid rec_len for '..' in inode %lu",
+ 			   dir->i_ino);
+ 		brelse(bh);
+@@ -1588,7 +1583,7 @@ static int ext4_dx_add_entry(handle_t *h
+ 
+ 		if (levels && (dx_get_count(frames->entries) ==
+ 			       dx_get_limit(frames->entries))) {
+-			ext4_warning(sb, __func__,
++			ext4_warning(sb,
+ 				     "Directory index full!");
+ 			err = -ENOSPC;
+ 			goto cleanup;
+@@ -1944,11 +1939,11 @@ static int empty_dir(struct inode *inode
+ 	if (inode->i_size < EXT4_DIR_REC_LEN(1) + EXT4_DIR_REC_LEN(2) ||
+ 	    !(bh = ext4_bread(NULL, inode, 0, 0, &err))) {
+ 		if (err)
+-			ext4_error(inode->i_sb, __func__,
++			ext4_error(inode->i_sb,
+ 				   "error %d reading directory #%lu offset 0",
+ 				   err, inode->i_ino);
+ 		else
+-			ext4_warning(inode->i_sb, __func__,
++			ext4_warning(inode->i_sb,
+ 				     "bad directory (dir #%lu) - no data block",
+ 				     inode->i_ino);
+ 		return 1;
+@@ -1959,7 +1954,7 @@ static int empty_dir(struct inode *inode
+ 			!le32_to_cpu(de1->inode) ||
+ 			strcmp(".", de->name) ||
+ 			strcmp("..", de1->name)) {
+-		ext4_warning(inode->i_sb, "empty_dir",
++		ext4_warning(inode->i_sb,
+ 			     "bad directory (dir #%lu) - no `.' or `..'",
+ 			     inode->i_ino);
+ 		brelse(bh);
+@@ -1977,7 +1972,7 @@ static int empty_dir(struct inode *inode
+ 				offset >> EXT4_BLOCK_SIZE_BITS(sb), 0, &err);
+ 			if (!bh) {
+ 				if (err)
+-					ext4_error(sb, __func__,
++					ext4_error(sb,
+ 						   "error %d reading directory"
+ 						   " #%lu offset %u",
+ 						   err, inode->i_ino, offset);
+@@ -2199,7 +2194,7 @@ static int ext4_rmdir(struct inode *dir,
+ 	if (retval)
+ 		goto end_rmdir;
+ 	if (!EXT4_DIR_LINK_EMPTY(inode))
+-		ext4_warning(inode->i_sb, "ext4_rmdir",
++		ext4_warning(inode->i_sb,
+ 			     "empty directory has too many links (%d)",
+ 			     inode->i_nlink);
+ 	inode->i_version++;
+@@ -2251,7 +2246,7 @@ static int ext4_unlink(struct inode *dir
+ 		goto end_unlink;
+ 
+ 	if (!inode->i_nlink) {
+-		ext4_warning(inode->i_sb, "ext4_unlink",
++		ext4_warning(inode->i_sb,
+ 			     "Deleting nonexistent file (%lu), %d",
+ 			     inode->i_ino, inode->i_nlink);
+ 		inode->i_nlink = 1;
+@@ -2498,7 +2493,7 @@ static int ext4_rename(struct inode *old
+ 		}
+ 	}
+ 	if (retval) {
+-		ext4_warning(old_dir->i_sb, "ext4_rename",
++		ext4_warning(old_dir->i_sb,
+ 				"Deleting old file (%lu), %d, error=%d",
+ 				old_dir->i_ino, old_dir->i_nlink, retval);
+ 	}
+diff -urpN linux-stage.orig/fs/ext4/resize.c linux-stage/fs/ext4/resize.c
+--- linux-stage.orig/fs/ext4/resize.c	2011-06-13 11:17:46.304669000 -0400
++++ linux-stage/fs/ext4/resize.c	2011-06-13 11:23:05.971685000 -0400
+@@ -48,63 +48,63 @@ static int verify_group_input(struct sup
+ 
+ 	ext4_get_group_no_and_offset(sb, start, NULL, &offset);
+ 	if (group != sbi->s_groups_count)
+-		ext4_warning(sb, __func__,
++		ext4_warning(sb,
+ 			     "Cannot add at group %u (only %u groups)",
+ 			     input->group, sbi->s_groups_count);
+ 	else if (offset != 0)
+-			ext4_warning(sb, __func__, "Last group not full");
++			ext4_warning(sb, "Last group not full");
+ 	else if (input->reserved_blocks > input->blocks_count / 5)
+-		ext4_warning(sb, __func__, "Reserved blocks too high (%u)",
++		ext4_warning(sb, "Reserved blocks too high (%u)",
+ 			     input->reserved_blocks);
+ 	else if (free_blocks_count < 0)
+-		ext4_warning(sb, __func__, "Bad blocks count %u",
++		ext4_warning(sb, "Bad blocks count %u",
+ 			     input->blocks_count);
+ 	else if (!(bh = sb_bread(sb, end - 1)))
+-		ext4_warning(sb, __func__,
++		ext4_warning(sb,
+ 			     "Cannot read last block (%llu)",
+ 			     end - 1);
+ 	else if (outside(input->block_bitmap, start, end))
+-		ext4_warning(sb, __func__,
++		ext4_warning(sb,
+ 			     "Block bitmap not in group (block %llu)",
+ 			     (unsigned long long)input->block_bitmap);
+ 	else if (outside(input->inode_bitmap, start, end))
+-		ext4_warning(sb, __func__,
++		ext4_warning(sb,
+ 			     "Inode bitmap not in group (block %llu)",
+ 			     (unsigned long long)input->inode_bitmap);
+ 	else if (outside(input->inode_table, start, end) ||
+ 		 outside(itend - 1, start, end))
+-		ext4_warning(sb, __func__,
++		ext4_warning(sb,
+ 			     "Inode table not in group (blocks %llu-%llu)",
+ 			     (unsigned long long)input->inode_table, itend - 1);
+ 	else if (input->inode_bitmap == input->block_bitmap)
+-		ext4_warning(sb, __func__,
++		ext4_warning(sb,
+ 			     "Block bitmap same as inode bitmap (%llu)",
+ 			     (unsigned long long)input->block_bitmap);
+ 	else if (inside(input->block_bitmap, input->inode_table, itend))
+-		ext4_warning(sb, __func__,
++		ext4_warning(sb,
+ 			     "Block bitmap (%llu) in inode table (%llu-%llu)",
+ 			     (unsigned long long)input->block_bitmap,
+ 			     (unsigned long long)input->inode_table, itend - 1);
+ 	else if (inside(input->inode_bitmap, input->inode_table, itend))
+-		ext4_warning(sb, __func__,
++		ext4_warning(sb,
+ 			     "Inode bitmap (%llu) in inode table (%llu-%llu)",
+ 			     (unsigned long long)input->inode_bitmap,
+ 			     (unsigned long long)input->inode_table, itend - 1);
+ 	else if (inside(input->block_bitmap, start, metaend))
+-		ext4_warning(sb, __func__,
++		ext4_warning(sb,
+ 			     "Block bitmap (%llu) in GDT table"
+ 			     " (%llu-%llu)",
+ 			     (unsigned long long)input->block_bitmap,
+ 			     start, metaend - 1);
+ 	else if (inside(input->inode_bitmap, start, metaend))
+-		ext4_warning(sb, __func__,
++		ext4_warning(sb,
+ 			     "Inode bitmap (%llu) in GDT table"
+ 			     " (%llu-%llu)",
+ 			     (unsigned long long)input->inode_bitmap,
+ 			     start, metaend - 1);
+ 	else if (inside(input->inode_table, start, metaend) ||
+ 		 inside(itend - 1, start, metaend))
+-		ext4_warning(sb, __func__,
++		ext4_warning(sb,
+ 			     "Inode table (%llu-%llu) overlaps"
+ 			     "GDT table (%llu-%llu)",
+ 			     (unsigned long long)input->inode_table,
+@@ -364,7 +364,7 @@ static int verify_reserved_gdb(struct su
+ 	while ((grp = ext4_list_backups(sb, &three, &five, &seven)) < end) {
+ 		if (le32_to_cpu(*p++) !=
+ 		    grp * EXT4_BLOCKS_PER_GROUP(sb) + blk){
+-			ext4_warning(sb, __func__,
++			ext4_warning(sb,
+ 				     "reserved GDT %llu"
+ 				     " missing grp %d (%llu)",
+ 				     blk, grp,
+@@ -420,7 +420,7 @@ static int add_new_gdb(handle_t *handle,
+          */
+ 	if (EXT4_SB(sb)->s_sbh->b_blocknr !=
+ 	    le32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block)) {
+-		ext4_warning(sb, __func__,
++		ext4_warning(sb,
+ 			"won't resize using backup superblock at %llu",
+ 			(unsigned long long)EXT4_SB(sb)->s_sbh->b_blocknr);
+ 		return -EPERM;
+@@ -444,7 +444,7 @@ static int add_new_gdb(handle_t *handle,
+ 
+ 	data = (__le32 *)dind->b_data;
+ 	if (le32_to_cpu(data[gdb_num % EXT4_ADDR_PER_BLOCK(sb)]) != gdblock) {
+-		ext4_warning(sb, __func__,
++		ext4_warning(sb,
+ 			     "new group %u GDT block %llu not reserved",
+ 			     input->group, gdblock);
+ 		err = -EINVAL;
+@@ -468,7 +468,7 @@ static int add_new_gdb(handle_t *handle,
+ 			GFP_NOFS);
+ 	if (!n_group_desc) {
+ 		err = -ENOMEM;
+-		ext4_warning(sb, __func__,
++		ext4_warning(sb,
+ 			      "not enough memory for %lu groups", gdb_num + 1);
+ 		goto exit_inode;
+ 	}
+@@ -567,7 +567,7 @@ static int reserve_backup_gdb(handle_t *
+ 	/* Get each reserved primary GDT block and verify it holds backups */
+ 	for (res = 0; res < reserved_gdb; res++, blk++) {
+ 		if (le32_to_cpu(*data) != blk) {
+-			ext4_warning(sb, __func__,
++			ext4_warning(sb,
+ 				     "reserved block %llu"
+ 				     " not at offset %ld",
+ 				     blk,
+@@ -713,7 +713,7 @@ static void update_backups(struct super_
+ 	 */
+ exit_err:
+ 	if (err) {
+-		ext4_warning(sb, __func__,
++		ext4_warning(sb,
+ 			     "can't update backup for group %u (err %d), "
+ 			     "forcing fsck on next reboot", group, err);
+ 		sbi->s_mount_state &= ~EXT4_VALID_FS;
+@@ -753,20 +753,20 @@ int ext4_group_add(struct super_block *s
+ 
+ 	if (gdb_off == 0 && !EXT4_HAS_RO_COMPAT_FEATURE(sb,
+ 					EXT4_FEATURE_RO_COMPAT_SPARSE_SUPER)) {
+-		ext4_warning(sb, __func__,
++		ext4_warning(sb,
+ 			     "Can't resize non-sparse filesystem further");
+ 		return -EPERM;
+ 	}
+ 
+ 	if (ext4_blocks_count(es) + input->blocks_count <
+ 	    ext4_blocks_count(es)) {
+-		ext4_warning(sb, __func__, "blocks_count overflow");
++		ext4_warning(sb, "blocks_count overflow");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (le32_to_cpu(es->s_inodes_count) + EXT4_INODES_PER_GROUP(sb) <
+ 	    le32_to_cpu(es->s_inodes_count)) {
+-		ext4_warning(sb, __func__, "inodes_count overflow");
++		ext4_warning(sb, "inodes_count overflow");
+ 		return -EINVAL;
+ 	}
+ 
+@@ -774,13 +774,13 @@ int ext4_group_add(struct super_block *s
+ 		if (!EXT4_HAS_COMPAT_FEATURE(sb,
+ 					     EXT4_FEATURE_COMPAT_RESIZE_INODE)
+ 		    || !le16_to_cpu(es->s_reserved_gdt_blocks)) {
+-			ext4_warning(sb, __func__,
++			ext4_warning(sb,
+ 				     "No reserved GDT blocks, can't resize");
+ 			return -EPERM;
+ 		}
+ 		inode = ext4_iget(sb, EXT4_RESIZE_INO);
+ 		if (IS_ERR(inode)) {
+-			ext4_warning(sb, __func__,
++			ext4_warning(sb,
+ 				     "Error opening resize inode");
+ 			return PTR_ERR(inode);
+ 		}
+@@ -810,7 +810,7 @@ int ext4_group_add(struct super_block *s
+ 
+ 	mutex_lock(&sbi->s_resize_lock);
+ 	if (input->group != sbi->s_groups_count) {
+-		ext4_warning(sb, __func__,
++		ext4_warning(sb,
+ 			     "multiple resizers run on filesystem!");
+ 		err = -EBUSY;
+ 		goto exit_journal;
+@@ -998,12 +998,12 @@ int ext4_group_extend(struct super_block
+ 			" too large to resize to %llu blocks safely\n",
+ 			sb->s_id, n_blocks_count);
+ 		if (sizeof(sector_t) < 8)
+-			ext4_warning(sb, __func__, "CONFIG_LBDAF not enabled");
++			ext4_warning(sb, "CONFIG_LBDAF not enabled");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (n_blocks_count < o_blocks_count) {
+-		ext4_warning(sb, __func__,
++		ext4_warning(sb,
+ 			     "can't shrink FS - resize aborted");
+ 		return -EBUSY;
+ 	}
+@@ -1012,7 +1012,7 @@ int ext4_group_extend(struct super_block
+ 	ext4_get_group_no_and_offset(sb, o_blocks_count, &group, &last);
+ 
+ 	if (last == 0) {
+-		ext4_warning(sb, __func__,
++		ext4_warning(sb,
+ 			     "need to use ext2online to resize further");
+ 		return -EPERM;
+ 	}
+@@ -1020,7 +1020,7 @@ int ext4_group_extend(struct super_block
+ 	add = EXT4_BLOCKS_PER_GROUP(sb) - last;
+ 
+ 	if (o_blocks_count + add < o_blocks_count) {
+-		ext4_warning(sb, __func__, "blocks_count overflow");
++		ext4_warning(sb, "blocks_count overflow");
+ 		return -EINVAL;
+ 	}
+ 
+@@ -1028,7 +1028,7 @@ int ext4_group_extend(struct super_block
+ 		add = n_blocks_count - o_blocks_count;
+ 
+ 	if (o_blocks_count + add < n_blocks_count)
+-		ext4_warning(sb, __func__,
++		ext4_warning(sb,
+ 			     "will only finish group (%llu"
+ 			     " blocks, %u new)",
+ 			     o_blocks_count + add, add);
+@@ -1036,7 +1036,7 @@ int ext4_group_extend(struct super_block
+ 	/* See if the device is actually as big as what was requested */
+ 	bh = sb_bread(sb, o_blocks_count + add - 1);
+ 	if (!bh) {
+-		ext4_warning(sb, __func__,
++		ext4_warning(sb,
+ 			     "can't read last block, resize aborted");
+ 		return -ENOSPC;
+ 	}
+@@ -1048,13 +1048,13 @@ int ext4_group_extend(struct super_block
+ 	handle = ext4_journal_start_sb(sb, 3);
+ 	if (IS_ERR(handle)) {
+ 		err = PTR_ERR(handle);
+-		ext4_warning(sb, __func__, "error %d on journal start", err);
++		ext4_warning(sb, "error %d on journal start", err);
+ 		goto exit_put;
+ 	}
+ 
+ 	mutex_lock(&EXT4_SB(sb)->s_resize_lock);
+ 	if (o_blocks_count != ext4_blocks_count(es)) {
+-		ext4_warning(sb, __func__,
++		ext4_warning(sb,
+ 			     "multiple resizers run on filesystem!");
+ 		mutex_unlock(&EXT4_SB(sb)->s_resize_lock);
+ 		ext4_journal_stop(handle);
+@@ -1064,7 +1064,7 @@ int ext4_group_extend(struct super_block
+ 
+ 	if ((err = ext4_journal_get_write_access(handle,
+ 						 EXT4_SB(sb)->s_sbh))) {
+-		ext4_warning(sb, __func__,
++		ext4_warning(sb,
+ 			     "error %d on journal write access", err);
+ 		mutex_unlock(&EXT4_SB(sb)->s_resize_lock);
+ 		ext4_journal_stop(handle);
+diff -urpN linux-stage.orig/fs/ext4/super.c linux-stage/fs/ext4/super.c
+--- linux-stage.orig/fs/ext4/super.c	2011-06-13 11:17:46.536437000 -0400
++++ linux-stage/fs/ext4/super.c	2011-06-13 11:23:05.983670000 -0400
+@@ -337,7 +337,7 @@ static void ext4_handle_error(struct sup
+ 			sb->s_id);
+ }
+ 
+-void ext4_error(struct super_block *sb, const char *function,
++void __ext4_error(struct super_block *sb, const char *function,
+ 		const char *fmt, ...)
+ {
+ 	va_list args;
+@@ -454,7 +454,7 @@ void ext4_msg (struct super_block * sb, 
+ 	va_end(args);
+ }
+ 
+-void ext4_warning(struct super_block *sb, const char *function,
++void __ext4_warning(struct super_block *sb, const char *function,
+ 		  const char *fmt, ...)
+ {
+ 	va_list args;
+@@ -511,7 +511,7 @@ void ext4_update_dynamic_rev(struct supe
+ 	if (le32_to_cpu(es->s_rev_level) > EXT4_GOOD_OLD_REV)
+ 		return;
+ 
+-	ext4_warning(sb, __func__,
++	ext4_warning(sb,
+ 		     "updating to rev %d because of new feature flag, "
+ 		     "running e2fsck is recommended",
+ 		     EXT4_DYNAMIC_REV);
+@@ -1096,9 +1096,9 @@ enum {
+ 	Opt_abort, Opt_data_journal, Opt_data_ordered, Opt_data_writeback,
+ 	Opt_data_err_abort, Opt_data_err_ignore,
+ 	Opt_usrjquota, Opt_grpjquota, Opt_offusrjquota, Opt_offgrpjquota,
+-	Opt_jqfmt_vfsold, Opt_jqfmt_vfsv0, Opt_quota, Opt_noquota,
+-	Opt_ignore, Opt_barrier, Opt_nobarrier, Opt_err, Opt_resize,
+-	Opt_usrquota, Opt_grpquota, Opt_i_version,
++	Opt_jqfmt_vfsold, Opt_jqfmt_vfsv0, Opt_jqfmt_vfsv1, Opt_quota,
++	Opt_noquota, Opt_ignore, Opt_barrier, Opt_nobarrier, Opt_err,
++	Opt_resize, Opt_usrquota, Opt_grpquota, Opt_i_version,
+ 	Opt_stripe, Opt_delalloc, Opt_nodelalloc,
+ 	Opt_block_validity, Opt_noblock_validity,
+ 	Opt_inode_readahead_blks, Opt_journal_ioprio,
+@@ -2709,6 +2709,21 @@ static int ext4_fill_super(struct super_
+ 	get_random_bytes(&sbi->s_next_generation, sizeof(u32));
+ 	spin_lock_init(&sbi->s_next_gen_lock);
+ 
++	err = percpu_counter_init(&sbi->s_freeblocks_counter,
++				  ext4_count_free_blocks(sb));
++	if (!err)
++		err = percpu_counter_init(&sbi->s_freeinodes_counter,
++					  ext4_count_free_inodes(sb));
++	if (!err)
++		err = percpu_counter_init(&sbi->s_dirs_counter,
++					  ext4_count_dirs(sb));
++	if (!err)
++		err = percpu_counter_init(&sbi->s_dirtyblocks_counter, 0);
++	if (err) {
++		ext4_msg(sb, KERN_ERR, "insufficient memory");
++		goto failed_mount3;
++	}
++
+ 	sbi->s_stripe = ext4_get_stripe_size(sbi);
+ 	sbi->s_max_writeback_mb_bump = 128;
+ 
+@@ -2828,20 +2843,6 @@ static int ext4_fill_super(struct super_
+ 	set_task_ioprio(sbi->s_journal->j_task, journal_ioprio);
+ 
+ no_journal:
+-	err = percpu_counter_init(&sbi->s_freeblocks_counter,
+-				  ext4_count_free_blocks(sb));
+-	if (!err)
+-		err = percpu_counter_init(&sbi->s_freeinodes_counter,
+-					  ext4_count_free_inodes(sb));
+-	if (!err)
+-		err = percpu_counter_init(&sbi->s_dirs_counter,
+-					  ext4_count_dirs(sb));
+-	if (!err)
+-		err = percpu_counter_init(&sbi->s_dirtyblocks_counter, 0);
+-	if (err) {
+-		ext4_msg(sb, KERN_ERR, "insufficient memory");
+-		goto failed_mount_wq;
+-	}
+ 	if (test_opt(sb, NOBH)) {
+ 		if (!(test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_WRITEBACK_DATA)) {
+ 			ext4_msg(sb, KERN_WARNING, "Ignoring nobh option - "
+@@ -2974,10 +2975,6 @@ failed_mount_wq:
+ 		jbd2_journal_destroy(sbi->s_journal);
+ 		sbi->s_journal = NULL;
+ 	}
+-	percpu_counter_destroy(&sbi->s_freeblocks_counter);
+-	percpu_counter_destroy(&sbi->s_freeinodes_counter);
+-	percpu_counter_destroy(&sbi->s_dirs_counter);
+-	percpu_counter_destroy(&sbi->s_dirtyblocks_counter);
+ failed_mount3:
+ 	if (sbi->s_flex_groups) {
+ 		if (is_vmalloc_addr(sbi->s_flex_groups))
+@@ -2985,6 +2982,10 @@ failed_mount3:
+ 		else
+ 			kfree(sbi->s_flex_groups);
+ 	}
++	percpu_counter_destroy(&sbi->s_freeblocks_counter);
++	percpu_counter_destroy(&sbi->s_freeinodes_counter);
++	percpu_counter_destroy(&sbi->s_dirs_counter);
++	percpu_counter_destroy(&sbi->s_dirtyblocks_counter);
+ failed_mount2:
+ 	for (i = 0; i < db_count; i++)
+ 		brelse(sbi->s_group_desc[i]);
+@@ -3377,9 +3378,9 @@ static void ext4_clear_journal_err(struc
+ 		char nbuf[16];
+ 
+ 		errstr = ext4_decode_error(sb, j_errno, nbuf);
+-		ext4_warning(sb, __func__, "Filesystem error recorded "
++		ext4_warning(sb, "Filesystem error recorded "
+ 			     "from previous mount: %s", errstr);
+-		ext4_warning(sb, __func__, "Marking fs in need of "
++		ext4_warning(sb, "Marking fs in need of "
+ 			     "filesystem check.");
+ 
+ 		EXT4_SB(sb)->s_mount_state |= EXT4_ERROR_FS;
+diff -urpN linux-stage.orig/fs/ext4/xattr.c linux-stage/fs/ext4/xattr.c
+--- linux-stage.orig/fs/ext4/xattr.c	2011-06-13 11:17:46.313660000 -0400
++++ linux-stage/fs/ext4/xattr.c	2011-06-13 11:23:05.990665000 -0400
+@@ -227,7 +227,7 @@ ext4_xattr_block_get(struct inode *inode
+ 	ea_bdebug(bh, "b_count=%d, refcount=%d",
+ 		atomic_read(&(bh->b_count)), le32_to_cpu(BHDR(bh)->h_refcount));
+ 	if (ext4_xattr_check_block(bh)) {
+-bad_block:	ext4_error(inode->i_sb, __func__,
++bad_block:	ext4_error(inode->i_sb,
+ 			   "inode %lu: bad block %llu", inode->i_ino,
+ 			   EXT4_I(inode)->i_file_acl);
+ 		error = -EIO;
+@@ -369,7 +369,7 @@ ext4_xattr_block_list(struct inode *inod
+ 	ea_bdebug(bh, "b_count=%d, refcount=%d",
+ 		atomic_read(&(bh->b_count)), le32_to_cpu(BHDR(bh)->h_refcount));
+ 	if (ext4_xattr_check_block(bh)) {
+-		ext4_error(inode->i_sb, __func__,
++		ext4_error(inode->i_sb,
+ 			   "inode %lu: bad block %llu", inode->i_ino,
+ 			   EXT4_I(inode)->i_file_acl);
+ 		error = -EIO;
+@@ -661,7 +661,7 @@ ext4_xattr_block_find(struct inode *inod
+ 			atomic_read(&(bs->bh->b_count)),
+ 			le32_to_cpu(BHDR(bs->bh)->h_refcount));
+ 		if (ext4_xattr_check_block(bs->bh)) {
+-			ext4_error(sb, __func__,
++			ext4_error(sb,
+ 				"inode %lu: bad block %llu", inode->i_ino,
+ 				EXT4_I(inode)->i_file_acl);
+ 			error = -EIO;
+@@ -875,7 +875,7 @@ cleanup_dquot:
+ 	goto cleanup;
+ 
+ bad_block:
+-	ext4_error(inode->i_sb, __func__,
++	ext4_error(inode->i_sb,
+ 		   "inode %lu: bad block %llu", inode->i_ino,
+ 		   EXT4_I(inode)->i_file_acl);
+ 	goto cleanup;
+@@ -1190,7 +1190,7 @@ retry:
+ 		if (!bh)
+ 			goto cleanup;
+ 		if (ext4_xattr_check_block(bh)) {
+-			ext4_error(inode->i_sb, __func__,
++			ext4_error(inode->i_sb,
+ 				"inode %lu: bad block %llu", inode->i_ino,
+ 				EXT4_I(inode)->i_file_acl);
+ 			error = -EIO;
+@@ -1367,14 +1367,14 @@ ext4_xattr_delete_inode(handle_t *handle
+ 		goto cleanup;
+ 	bh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);
+ 	if (!bh) {
+-		ext4_error(inode->i_sb, __func__,
++		ext4_error(inode->i_sb,
+ 			"inode %lu: block %llu read error", inode->i_ino,
+ 			EXT4_I(inode)->i_file_acl);
+ 		goto cleanup;
+ 	}
+ 	if (BHDR(bh)->h_magic != cpu_to_le32(EXT4_XATTR_MAGIC) ||
+ 	    BHDR(bh)->h_blocks != cpu_to_le32(1)) {
+-		ext4_error(inode->i_sb, __func__,
++		ext4_error(inode->i_sb,
+ 			"inode %lu: bad block %llu", inode->i_ino,
+ 			EXT4_I(inode)->i_file_acl);
+ 		goto cleanup;
+@@ -1501,7 +1501,7 @@ again:
+ 		}
+ 		bh = sb_bread(inode->i_sb, ce->e_block);
+ 		if (!bh) {
+-			ext4_error(inode->i_sb, __func__,
++			ext4_error(inode->i_sb,
+ 				"inode %lu: block %lu read error",
+ 				inode->i_ino, (unsigned long) ce->e_block);
+ 		} else if (le32_to_cpu(BHDR(bh)->h_refcount) >=
diff -urpN linux-stage.orig/fs/ext4/balloc.c linux-stage/fs/ext4/balloc.c
--- linux-stage.orig/fs/ext4/balloc.c	2011-06-13 11:17:46.514457000 -0400
+++ linux-stage/fs/ext4/balloc.c	2011-06-13 11:29:41.244012000 -0400
@@ -97,7 +97,7 @@ unsigned ext4_init_block_bitmap(struct s
 		/* If checksum is bad mark all blocks used to prevent allocation
 		 * essentially implementing a per-group read-only flag. */
 		if (!ext4_group_desc_csum_verify(sbi, block_group, gdp)) {
-			ext4_error(sb, __func__,
+			ext4_error(sb,
 				  "Checksum bad for group %u", block_group);
 			ext4_free_blks_set(sb, gdp, 0);
 			ext4_free_inodes_set(sb, gdp, 0);
@@ -207,10 +207,8 @@ struct ext4_group_desc * ext4_get_group_
 	struct ext4_sb_info *sbi = EXT4_SB(sb);
 
 	if (block_group >= ngroups) {
-		ext4_error(sb, "ext4_get_group_desc",
-			   "block_group >= groups_count - "
-			   "block_group = %u, groups_count = %u",
-			   block_group, ngroups);
+		ext4_error(sb, "block_group >= groups_count - block_group = %u,"
+			   " groups_count = %u", block_group, ngroups);
 
 		return NULL;
 	}
@@ -218,8 +216,7 @@ struct ext4_group_desc * ext4_get_group_
 	group_desc = block_group >> EXT4_DESC_PER_BLOCK_BITS(sb);
 	offset = block_group & (EXT4_DESC_PER_BLOCK(sb) - 1);
 	if (!sbi->s_group_desc[group_desc]) {
-		ext4_error(sb, "ext4_get_group_desc",
-			   "Group descriptor not loaded - "
+		ext4_error(sb, "Group descriptor not loaded - "
 			   "block_group = %u, group_desc = %u, desc = %u",
 			   block_group, group_desc, offset);
 		return NULL;
@@ -280,7 +277,7 @@ static int ext4_valid_block_bitmap(struc
 		return 1;
 
 err_out:
-	ext4_error(sb, __func__,
+	ext4_error(sb,
 			"Invalid block bitmap - "
 			"block_group = %d, block = %llu",
 			block_group, bitmap_blk);
@@ -309,7 +306,7 @@ ext4_read_block_bitmap(struct super_bloc
 	bitmap_blk = ext4_block_bitmap(sb, desc);
 	bh = sb_getblk(sb, bitmap_blk);
 	if (unlikely(!bh)) {
-		ext4_error(sb, __func__,
+		ext4_error(sb,
 			    "Cannot read block bitmap - "
 			    "block_group = %u, block_bitmap = %llu",
 			    block_group, bitmap_blk);
@@ -352,7 +349,7 @@ ext4_read_block_bitmap(struct super_bloc
 	set_bitmap_uptodate(bh);
 	if (bh_submit_read(bh) < 0) {
 		put_bh(bh);
-		ext4_error(sb, __func__,
+		ext4_error(sb,
 			    "Cannot read block bitmap - "
 			    "block_group = %u, block_bitmap = %llu",
 			    block_group, bitmap_blk);
@@ -417,7 +414,7 @@ void ext4_add_groupblocks(handle_t *hand
 	    in_range(block, ext4_inode_table(sb, desc), sbi->s_itb_per_group) ||
 	    in_range(block + count - 1, ext4_inode_table(sb, desc),
 		     sbi->s_itb_per_group)) {
-		ext4_error(sb, __func__,
+		ext4_error(sb,
 			   "Adding blocks in system zones - "
 			   "Block = %llu, count = %lu",
 			   block, count);
@@ -451,7 +448,7 @@ void ext4_add_groupblocks(handle_t *hand
 		BUFFER_TRACE(bitmap_bh, "clear bit");
 		if (!ext4_clear_bit_atomic(ext4_group_lock_ptr(sb, block_group),
 						bit + i, bitmap_bh->b_data)) {
-			ext4_error(sb, __func__,
+			ext4_error(sb,
 				   "bit already cleared for block %llu",
 				   (ext4_fsblk_t)(block + i));
 			BUFFER_TRACE(bitmap_bh, "bit already cleared");
diff -urpN linux-stage.orig/fs/ext4/dir.c linux-stage/fs/ext4/dir.c
--- linux-stage.orig/fs/ext4/dir.c	2011-06-13 11:17:46.251720000 -0400
+++ linux-stage/fs/ext4/dir.c	2011-06-13 11:29:41.249009000 -0400
@@ -83,7 +83,7 @@ int ext4_check_dir_entry(const char *fun
 		error_msg = "inode out of bounds";
 
 	if (error_msg != NULL)
-		ext4_error(dir->i_sb, function,
+		ext4_error(dir->i_sb,
 			"bad entry in directory #%lu: %s - block=%llu"
 			"offset=%u(%u), inode=%u, rec_len=%d, name_len=%d",
 			dir->i_ino, error_msg,
@@ -152,7 +152,7 @@ static int ext4_readdir(struct file *fil
 		 */
 		if (!bh) {
 			if (!dir_has_error) {
-				ext4_error(sb, __func__, "directory #%lu "
+				ext4_error(sb, "directory #%lu "
 					   "contains a hole at offset %Lu",
 					   inode->i_ino,
 					   (unsigned long long) filp->f_pos);
diff -urpN linux-stage.orig/fs/ext4/ext4.h linux-stage/fs/ext4/ext4.h
--- linux-stage.orig/fs/ext4/ext4.h	2011-06-13 11:17:46.603372000 -0400
+++ linux-stage/fs/ext4/ext4.h	2011-06-13 11:30:04.990244000 -0400
@@ -23,6 +23,7 @@
 #include <linux/quota.h>
 #include <linux/rwsem.h>
 #include <linux/rbtree.h>
+#include <linux/kernel.h>
 #include <linux/seqlock.h>
 #include <linux/mutex.h>
 #include <linux/timer.h>
@@ -1509,6 +1510,7 @@ extern struct buffer_head *ext4_read_ino
 						  ext4_group_t block_group);
 
 /* mballoc.c */
+struct fstrim_range;
 extern long ext4_mb_stats;
 extern long ext4_mb_max_to_scan;
 extern int ext4_mb_init(struct super_block *, int);
@@ -1526,6 +1528,8 @@ extern int ext4_mb_add_groupinfo(struct 
 extern int ext4_mb_get_buddy_cache_lock(struct super_block *, ext4_group_t);
 extern void ext4_mb_put_buddy_cache_lock(struct super_block *,
 						ext4_group_t, int);
+extern int ext4_trim_fs(struct super_block *, struct fstrim_range *);
+
 /* inode.c */
 int ext4_forget(handle_t *handle, int is_metadata, struct inode *inode,
 		struct buffer_head *bh, ext4_fsblk_t blocknr);
@@ -1586,13 +1590,15 @@ extern int ext4_group_extend(struct supe
 				ext4_fsblk_t n_blocks_count);
 
 /* super.c */
-extern void ext4_error(struct super_block *, const char *, const char *, ...)
+extern void __ext4_error(struct super_block *, const char *, const char *, ...)
 	__attribute__ ((format (printf, 3, 4)));
+#define ext4_error(sb, message...)	__ext4_error(sb, __func__, ## message)
 extern void __ext4_std_error(struct super_block *, const char *, int);
 extern void ext4_abort(struct super_block *, const char *, const char *, ...)
 	__attribute__ ((format (printf, 3, 4)));
-extern void ext4_warning(struct super_block *, const char *, const char *, ...)
+extern void __ext4_warning(struct super_block *, const char *, const char *, ...)
 	__attribute__ ((format (printf, 3, 4)));
+#define ext4_warning(sb, message...)	__ext4_warning(sb, __func__, ## message)
 extern void ext4_msg(struct super_block *, const char *, const char *, ...)
 	__attribute__ ((format (printf, 3, 4)));
 extern void ext4_grp_locked_error(struct super_block *, ext4_group_t,
diff -urpN linux-stage.orig/fs/ext4/ext4_jbd2.c linux-stage/fs/ext4/ext4_jbd2.c
--- linux-stage.orig/fs/ext4/ext4_jbd2.c	2011-06-13 11:17:46.253719000 -0400
+++ linux-stage/fs/ext4/ext4_jbd2.c	2011-06-13 11:29:41.260996000 -0400
@@ -96,7 +96,7 @@ int __ext4_handle_dirty_metadata(const c
 		if (inode && inode_needs_sync(inode)) {
 			sync_dirty_buffer(bh);
 			if (buffer_req(bh) && !buffer_uptodate(bh)) {
-				ext4_error(inode->i_sb, __func__,
+				ext4_error(inode->i_sb,
 					   "IO error syncing inode, "
 					   "inode=%lu, block=%llu",
 					   inode->i_ino,
diff -urpN linux-stage.orig/fs/ext4/extents.c linux-stage/fs/ext4/extents.c
--- linux-stage.orig/fs/ext4/extents.c	2011-06-13 11:17:46.567406000 -0400
+++ linux-stage/fs/ext4/extents.c	2011-06-13 11:29:41.270985000 -0400
@@ -437,7 +437,7 @@ static int __ext4_ext_check(const char *
 	return 0;
 
 corrupted:
-	ext4_error(inode->i_sb, function,
+	ext4_error(inode->i_sb,
 			"bad header/extent in inode #%lu: %s - magic %x, "
 			"entries %u, max %u(%u), depth %u(%u)",
 			inode->i_ino, error_msg, le16_to_cpu(eh->eh_magic),
@@ -1534,7 +1534,7 @@ int ext4_ext_try_to_merge(struct inode *
 		merge_done = 1;
 		WARN_ON(eh->eh_entries == 0);
 		if (!eh->eh_entries)
-			ext4_error(inode->i_sb, "ext4_ext_try_to_merge",
+			ext4_error(inode->i_sb,
 			   "inode#%lu, eh->eh_entries = 0!", inode->i_ino);
 	}
 
@@ -3284,7 +3284,7 @@ int ext4_ext_get_blocks(handle_t *handle
 	 * this is why assert can't be put in ext4_ext_find_extent()
 	 */
 	if (path[depth].p_ext == NULL && depth != 0) {
-		ext4_error(inode->i_sb, __func__, "bad extent address "
+		ext4_error(inode->i_sb, "bad extent address "
 			   "inode: %lu, iblock: %lu, depth: %d",
 			   inode->i_ino, (unsigned long) iblock, depth);
 		err = -EIO;
@@ -3415,7 +3415,7 @@ int ext4_ext_get_blocks(handle_t *handle
 
 	if (unlikely(ext4_test_inode_flag(inode, EXT4_INODE_EOFBLOCKS))) {
 		if (unlikely(!eh->eh_entries)) {
-			ext4_error(inode->i_sb, __func__,
+			ext4_error(inode->i_sb,
 				   "inode#%lu, eh->eh_entries = 0 and "
 				   "EOFBLOCKS_FL set", inode->i_ino);
 			err = -EIO;
diff -urpN linux-stage.orig/fs/ext4/ialloc.c linux-stage/fs/ext4/ialloc.c
--- linux-stage.orig/fs/ext4/ialloc.c	2011-06-13 11:17:46.594379000 -0400
+++ linux-stage/fs/ext4/ialloc.c	2011-06-13 11:29:41.276981000 -0400
@@ -76,7 +76,7 @@ unsigned ext4_init_inode_bitmap(struct s
 	/* If checksum is bad mark all blocks and inodes use to prevent
 	 * allocation, essentially implementing a per-group read-only flag. */
 	if (!ext4_group_desc_csum_verify(sbi, block_group, gdp)) {
-		ext4_error(sb, __func__, "Checksum bad for group %u",
+		ext4_error(sb, "Checksum bad for group %u",
 			   block_group);
 		ext4_free_blks_set(sb, gdp, 0);
 		ext4_free_inodes_set(sb, gdp, 0);
@@ -111,7 +111,7 @@ ext4_read_inode_bitmap(struct super_bloc
 	bitmap_blk = ext4_inode_bitmap(sb, desc);
 	bh = sb_getblk(sb, bitmap_blk);
 	if (unlikely(!bh)) {
-		ext4_error(sb, __func__,
+		ext4_error(sb,
 			    "Cannot read inode bitmap - "
 			    "block_group = %u, inode_bitmap = %llu",
 			    block_group, bitmap_blk);
@@ -153,7 +153,7 @@ ext4_read_inode_bitmap(struct super_bloc
 	set_bitmap_uptodate(bh);
 	if (bh_submit_read(bh) < 0) {
 		put_bh(bh);
-		ext4_error(sb, __func__,
+		ext4_error(sb,
 			    "Cannot read inode bitmap - "
 			    "block_group = %u, inode_bitmap = %llu",
 			    block_group, bitmap_blk);
@@ -230,8 +230,7 @@ void ext4_free_inode(handle_t *handle, s
 
 	es = EXT4_SB(sb)->s_es;
 	if (ino < EXT4_FIRST_INO(sb) || ino > le32_to_cpu(es->s_inodes_count)) {
-		ext4_error(sb, "ext4_free_inode",
-			   "reserved or nonexistent inode %lu", ino);
+		ext4_error(sb, "reserved or nonexistent inode %lu", ino);
 		goto error_return;
 	}
 	block_group = (ino - 1) / EXT4_INODES_PER_GROUP(sb);
@@ -286,11 +285,10 @@ out:
 			fatal = err;
 		sb->s_dirt = 1;
 	} else
-		ext4_error(sb, "ext4_free_inode",
-			   "bit already cleared for inode %lu", ino);
+		ext4_error(sb, "bit already cleared for inode %lu", ino);
 
 error_return:
-	brelse(bitmap_bh);
+	brelse(bitmap_bh); 
 	ext4_std_error(sb, fatal);
 }
 
@@ -730,7 +728,7 @@ static int ext4_claim_inode(struct super
 	if ((group == 0 && ino < EXT4_FIRST_INO(sb)) ||
 			ino > EXT4_INODES_PER_GROUP(sb)) {
 		ext4_unlock_group(sb, group);
-		ext4_error(sb, __func__,
+		ext4_error(sb,
 			   "reserved inode or inode > inodes count - "
 			   "block_group = %u, inode=%lu", group,
 			   ino + group * EXT4_INODES_PER_GROUP(sb));
@@ -1094,7 +1092,7 @@ struct inode *ext4_orphan_get(struct sup
 
 	/* Error cases - e2fsck has already cleaned up for us */
 	if (ino > max_ino) {
-		ext4_warning(sb, __func__,
+		ext4_warning(sb,
 			     "bad orphan ino %lu!  e2fsck was run?", ino);
 		goto error;
 	}
@@ -1103,7 +1101,7 @@ struct inode *ext4_orphan_get(struct sup
 	bit = (ino - 1) % EXT4_INODES_PER_GROUP(sb);
 	bitmap_bh = ext4_read_inode_bitmap(sb, block_group);
 	if (!bitmap_bh) {
-		ext4_warning(sb, __func__,
+		ext4_warning(sb,
 			     "inode bitmap error for orphan %lu", ino);
 		goto error;
 	}
@@ -1136,7 +1134,7 @@ iget_failed:
 	err = PTR_ERR(inode);
 	inode = NULL;
 bad_orphan:
-	ext4_warning(sb, __func__,
+	ext4_warning(sb,
 		     "bad orphan inode %lu!  e2fsck was run?", ino);
 	printk(KERN_NOTICE "ext4_test_bit(bit=%d, block=%llu) = %d\n",
 	       bit, (unsigned long long)bitmap_bh->b_blocknr,
diff -urpN linux-stage.orig/fs/ext4/inode.c linux-stage/fs/ext4/inode.c
--- linux-stage.orig/fs/ext4/inode.c	2011-06-13 11:17:46.586385000 -0400
+++ linux-stage/fs/ext4/inode.c	2011-06-13 11:29:41.289970000 -0400
@@ -246,7 +246,7 @@ void ext4_delete_inode(struct inode *ino
 	inode->i_size = 0;
 	err = ext4_mark_inode_dirty(handle, inode);
 	if (err) {
-		ext4_warning(inode->i_sb, __func__,
+		ext4_warning(inode->i_sb,
 			     "couldn't mark inode dirty (err %d)", err);
 		goto stop_handle;
 	}
@@ -264,7 +264,7 @@ void ext4_delete_inode(struct inode *ino
 		if (err > 0)
 			err = ext4_journal_restart(handle, 3);
 		if (err != 0) {
-			ext4_warning(inode->i_sb, __func__,
+			ext4_warning(inode->i_sb,
 				     "couldn't extend journal (err %d)", err);
 		stop_handle:
 			ext4_journal_stop(handle);
@@ -375,8 +375,7 @@ static int ext4_block_to_path(struct ino
 		offsets[n++] = i_block & (ptrs - 1);
 		final = ptrs;
 	} else {
-		ext4_warning(inode->i_sb, "ext4_block_to_path",
-			     "block %lu > max in inode %lu",
+		ext4_warning(inode->i_sb, "block %lu > max in inode %lu",
 			     i_block + direct_blocks +
 			     indirect_blocks + double_blocks, inode->i_ino);
 	}
@@ -396,7 +395,7 @@ static int __ext4_check_blockref(const c
 		if (blk &&
 		    unlikely(!ext4_data_block_valid(EXT4_SB(inode->i_sb),
 						    blk, 1))) {
-			ext4_error(inode->i_sb, function,
+			ext4_error(inode->i_sb,
 				   "invalid block reference %u "
 				   "in inode #%lu", blk, inode->i_ino);
 			return -EIO;
@@ -1167,7 +1166,7 @@ static int check_block_validity(struct i
 				sector_t logical, sector_t phys, int len)
 {
 	if (!ext4_data_block_valid(EXT4_SB(inode->i_sb), phys, len)) {
-		ext4_error(inode->i_sb, msg,
+		ext4_error(inode->i_sb,
 			   "inode #%lu logical block %llu mapped to %llu "
 			   "(size %d)", inode->i_ino,
 			   (unsigned long long) logical,
@@ -4312,7 +4311,7 @@ static void ext4_free_data(handle_t *han
 		if ((EXT4_JOURNAL(inode) == NULL) || bh2jh(this_bh))
 			ext4_handle_dirty_metadata(handle, inode, this_bh);
 		else
-			ext4_error(inode->i_sb, __func__,
+			ext4_error(inode->i_sb,
 				   "circular indirect block detected, "
 				   "inode=%lu, block=%llu",
 				   inode->i_ino,
@@ -4360,7 +4359,7 @@ static void ext4_free_branches(handle_t 
 			 * (should be rare).
 			 */
 			if (!bh) {
-				ext4_error(inode->i_sb, "ext4_free_branches",
+				ext4_error(inode->i_sb,
 					   "Read failure, inode=%lu, block=%llu",
 					   inode->i_ino, nr);
 				continue;
@@ -4676,9 +4675,8 @@ static int __ext4_get_inode_loc(struct i
 
 	bh = sb_getblk(sb, block);
 	if (!bh) {
-		ext4_error(sb, "ext4_get_inode_loc", "unable to read "
-			   "inode block - inode=%lu, block=%llu",
-			   inode->i_ino, block);
+		ext4_error(sb, "unable to read inode block - "
+			   "inode=%lu, block=%llu", inode->i_ino, block);
 		return -EIO;
 	}
 	if (!buffer_uptodate(bh)) {
@@ -4776,7 +4774,7 @@ make_io:
 		submit_bh(READ_META, bh);
 		wait_on_buffer(bh);
 		if (!buffer_uptodate(bh)) {
-			ext4_error(sb, __func__,
+			ext4_error(sb,
 				   "unable to read inode block - inode=%lu, "
 				   "block=%llu", inode->i_ino, block);
 			brelse(bh);
@@ -4989,7 +4987,7 @@ struct inode *ext4_iget(struct super_blo
 	ret = 0;
 	if (ei->i_file_acl &&
 	    !ext4_data_block_valid(EXT4_SB(sb), ei->i_file_acl, 1)) {
-		ext4_error(sb, __func__,
+		ext4_error(sb,
 			   "bad extended attribute block %llu in inode #%lu",
 			   ei->i_file_acl, inode->i_ino);
 		ret = -EIO;
@@ -5036,7 +5034,7 @@ struct inode *ext4_iget(struct super_blo
 			   new_decode_dev(le32_to_cpu(raw_inode->i_block[1])));
 	} else {
 		ret = -EIO;
-		ext4_error(inode->i_sb, __func__,
+		ext4_error(inode->i_sb,
 			   "bogus i_mode (%o) for inode=%lu",
 			   inode->i_mode, inode->i_ino);
 		goto bad_inode;
@@ -5276,7 +5274,7 @@ int ext4_write_inode(struct inode *inode
 		if (wait)
 			sync_dirty_buffer(iloc.bh);
 		if (buffer_req(iloc.bh) && !buffer_uptodate(iloc.bh)) {
-			ext4_error(inode->i_sb, __func__,
+			ext4_error(inode->i_sb,
 				   "IO error syncing inode, "
 				   "inode=%lu, block=%llu",
 				   inode->i_ino,
@@ -5698,7 +5696,7 @@ int ext4_mark_inode_dirty(handle_t *hand
 						     EXT4_STATE_NO_EXPAND);
 				if (mnt_count !=
 					le16_to_cpu(sbi->s_es->s_mnt_count)) {
-					ext4_warning(inode->i_sb, __func__,
+					ext4_warning(inode->i_sb,
 					"Unable to expand inode %lu. Delete"
 					" some EAs or run e2fsck.",
 					inode->i_ino);
diff -urpN linux-stage.orig/fs/ext4/mballoc.c linux-stage/fs/ext4/mballoc.c
--- linux-stage.orig/fs/ext4/mballoc.c	2011-06-13 11:17:46.291682000 -0400
+++ linux-stage/fs/ext4/mballoc.c	2011-06-13 11:29:41.301954000 -0400
@@ -1860,7 +1860,6 @@ void ext4_mb_scan_aligned(struct ext4_al
 	}
 }
 
-/* This is now called BEFORE we load the buddy bitmap. */
 static int ext4_mb_good_group(struct ext4_allocation_context *ac,
 				ext4_group_t group, int cr)
 {
@@ -2160,6 +2159,11 @@ static void *ext4_mb_seq_groups_next(str
 	return (void *) ((unsigned long) group);
 }
 
+static inline void ext4_mb_release_desc(struct ext4_buddy *e4b)
+{
+	ext4_mb_unload_buddy(e4b);
+}
+
 static int ext4_mb_seq_groups_show(struct seq_file *seq, void *v)
 {
 	struct super_block *sb = seq->private;
@@ -2191,7 +2195,7 @@ static int ext4_mb_seq_groups_show(struc
 	ext4_lock_group(sb, group);
 	memcpy(&sg, ext4_get_group_info(sb, group), i);
 	ext4_unlock_group(sb, group);
-	ext4_mb_unload_buddy(&e4b);
+	ext4_mb_release_desc(&e4b);
 
 	seq_printf(seq, "#%-5u: %-5u %-5u %-5u [", group, sg.info.bb_free,
 			sg.info.bb_fragments, sg.info.bb_first_free);
@@ -2590,7 +2594,7 @@ static void release_blocks_on_commit(jou
 					entry->count);
 			ret = sb_issue_discard(sb, discard_block, entry->count);
 			if (ret == EOPNOTSUPP) {
-				ext4_warning(sb, __func__,
+				ext4_warning(sb,
 					"discard not supported, disabling");
 				clear_opt(EXT4_SB(sb)->s_mount_opt, DISCARD);
 			}
@@ -2755,7 +2759,7 @@ ext4_mb_mark_diskspace_used(struct ext4_
 
 	len = ac->ac_b_ex.fe_len;
 	if (!ext4_data_block_valid(sbi, block, len)) {
-		ext4_error(sb, __func__,
+		ext4_error(sb,
 			   "Allocating blocks %llu-%llu which overlap "
 			   "fs metadata\n", block, block+len);
 		/* File system mounted not to panic on error
@@ -3669,14 +3673,14 @@ ext4_mb_discard_group_preallocations(str
 
 	bitmap_bh = ext4_read_block_bitmap(sb, group);
 	if (bitmap_bh == NULL) {
-		ext4_error(sb, __func__, "Error in reading block "
+		ext4_error(sb, "Error in reading block "
 				"bitmap for %u", group);
 		return 0;
 	}
 
 	err = ext4_mb_load_buddy(sb, group, &e4b);
 	if (err) {
-		ext4_error(sb, __func__, "Error in loading buddy "
+		ext4_error(sb, "Error in loading buddy "
 				"information for %u", group);
 		put_bh(bitmap_bh);
 		return 0;
@@ -3850,14 +3854,14 @@ repeat:
 
 		err = ext4_mb_load_buddy(sb, group, &e4b);
 		if (err) {
-			ext4_error(sb, __func__, "Error in loading buddy "
-					"information for %u", group);
+			ext4_error(sb, "Error in loading buddy information for %u",
+					group);
 			continue;
 		}
 
 		bitmap_bh = ext4_read_block_bitmap(sb, group);
 		if (bitmap_bh == NULL) {
-			ext4_error(sb, __func__, "Error in reading block "
+			ext4_error(sb, "Error in reading block "
 					"bitmap for %u", group);
 			ext4_mb_unload_buddy(&e4b);
 			continue;
@@ -4123,7 +4127,7 @@ ext4_mb_discard_lg_preallocations(struct
 
 		ext4_get_group_no_and_offset(sb, pa->pa_pstart, &group, NULL);
 		if (ext4_mb_load_buddy(sb, group, &e4b)) {
-			ext4_error(sb, __func__, "Error in loading buddy "
+			ext4_error(sb, "Error in loading buddy "
 					"information for %u", group);
 			continue;
 		}
@@ -4514,7 +4518,7 @@ void ext4_mb_free_blocks(handle_t *handl
 	if (block < le32_to_cpu(es->s_first_data_block) ||
 	    block + count < block ||
 	    block + count > ext4_blocks_count(es)) {
-		ext4_error(sb, __func__,
+		ext4_error(sb,
 			    "Freeing blocks not in datazone - "
 			    "block = %llu, count = %lu", block, count);
 		goto error_return;
@@ -4559,7 +4563,7 @@ do_more:
 	    in_range(block + count - 1, ext4_inode_table(sb, gdp),
 		      EXT4_SB(sb)->s_itb_per_group)) {
 
-		ext4_error(sb, __func__,
+		ext4_error(sb,
 			   "Freeing blocks in system zone - "
 			   "Block = %llu, count = %lu", block, count);
 		/* err = 0. ext4_std_error should be a no op */
diff -urpN linux-stage.orig/fs/ext4/move_extent.c linux-stage/fs/ext4/move_extent.c
--- linux-stage.orig/fs/ext4/move_extent.c	2011-06-13 11:17:46.297674000 -0400
+++ linux-stage/fs/ext4/move_extent.c	2011-06-13 11:29:41.308949000 -0400
@@ -152,12 +152,12 @@ mext_check_null_inode(struct inode *inod
 	int ret = 0;
 
 	if (inode1 == NULL) {
-		ext4_error(inode2->i_sb, function,
+		ext4_error(inode2->i_sb,
 			"Both inodes should not be NULL: "
 			"inode1 NULL inode2 %lu", inode2->i_ino);
 		ret = -EIO;
 	} else if (inode2 == NULL) {
-		ext4_error(inode1->i_sb, function,
+		ext4_error(inode1->i_sb,
 			"Both inodes should not be NULL: "
 			"inode1 %lu inode2 NULL", inode1->i_ino);
 		ret = -EIO;
@@ -528,7 +528,7 @@ mext_leaf_block(handle_t *handle, struct
 	 * new_ext       |-------|
 	 */
 	if (le32_to_cpu(oext->ee_block) + oext_alen - 1 < new_ext_end) {
-		ext4_error(orig_inode->i_sb, __func__,
+		ext4_error(orig_inode->i_sb,
 			"new_ext_end(%u) should be less than or equal to "
 			"oext->ee_block(%u) + oext_alen(%d) - 1",
 			new_ext_end, le32_to_cpu(oext->ee_block),
@@ -691,12 +691,12 @@ mext_replace_branches(handle_t *handle, 
 	while (1) {
 		/* The extent for donor must be found. */
 		if (!dext) {
-			ext4_error(donor_inode->i_sb, __func__,
+			ext4_error(donor_inode->i_sb,
 				   "The extent for donor must be found");
 			*err = -EIO;
 			goto out;
 		} else if (donor_off != le32_to_cpu(tmp_dext.ee_block)) {
-			ext4_error(donor_inode->i_sb, __func__,
+			ext4_error(donor_inode->i_sb,
 				"Donor offset(%u) and the first block of donor "
 				"extent(%u) should be equal",
 				donor_off,
@@ -1356,7 +1356,7 @@ ext4_move_extents(struct file *o_filp, s
 			if (ret1 < 0)
 				break;
 			if (*moved_len > len) {
-				ext4_error(orig_inode->i_sb, __func__,
+				ext4_error(orig_inode->i_sb,
 					"We replaced blocks too much! "
 					"sum of replaced: %llu requested: %llu",
 					*moved_len, len);
diff -urpN linux-stage.orig/fs/ext4/namei.c linux-stage/fs/ext4/namei.c
--- linux-stage.orig/fs/ext4/namei.c	2011-06-13 11:17:46.439536000 -0400
+++ linux-stage/fs/ext4/namei.c	2011-06-13 11:29:41.317938000 -0400
@@ -394,8 +394,7 @@ dx_probe(const struct qstr *d_name, stru
 	if (root->info.hash_version != DX_HASH_TEA &&
 	    root->info.hash_version != DX_HASH_HALF_MD4 &&
 	    root->info.hash_version != DX_HASH_LEGACY) {
-		ext4_warning(dir->i_sb, __func__,
-			     "Unrecognised inode hash code %d",
+		ext4_warning(dir->i_sb, "Unrecognised inode hash code %d",
 			     root->info.hash_version);
 		brelse(bh);
 		*err = ERR_BAD_DX_DIR;
@@ -410,8 +409,7 @@ dx_probe(const struct qstr *d_name, stru
 	hash = hinfo->hash;
 
 	if (root->info.unused_flags & 1) {
-		ext4_warning(dir->i_sb, __func__,
-			     "Unimplemented inode hash flags: %#06x",
+		ext4_warning(dir->i_sb, "Unimplemented inode hash flags: %#06x",
 			     root->info.unused_flags);
 		brelse(bh);
 		*err = ERR_BAD_DX_DIR;
@@ -419,8 +417,7 @@ dx_probe(const struct qstr *d_name, stru
 	}
 
 	if ((indirect = root->info.indirect_levels) > 1) {
-		ext4_warning(dir->i_sb, __func__,
-			     "Unimplemented inode hash depth: %#06x",
+		ext4_warning(dir->i_sb, "Unimplemented inode hash depth: %#06x",
 			     root->info.indirect_levels);
 		brelse(bh);
 		*err = ERR_BAD_DX_DIR;
@@ -432,8 +429,7 @@ dx_probe(const struct qstr *d_name, stru
 
 	if (dx_get_limit(entries) != dx_root_limit(dir,
 						   root->info.info_length)) {
-		ext4_warning(dir->i_sb, __func__,
-			     "dx entry: limit != root limit");
+		ext4_warning(dir->i_sb, "dx entry: limit != root limit");
 		brelse(bh);
 		*err = ERR_BAD_DX_DIR;
 		goto fail;
@@ -444,7 +440,7 @@ dx_probe(const struct qstr *d_name, stru
 	{
 		count = dx_get_count(entries);
 		if (!count || count > dx_get_limit(entries)) {
-			ext4_warning(dir->i_sb, __func__,
+			ext4_warning(dir->i_sb,
 				     "dx entry: no count or count > limit");
 			brelse(bh);
 			*err = ERR_BAD_DX_DIR;
@@ -489,7 +485,7 @@ dx_probe(const struct qstr *d_name, stru
 			goto fail2;
 		at = entries = ((struct dx_node *) bh->b_data)->entries;
 		if (dx_get_limit(entries) != dx_node_limit (dir)) {
-			ext4_warning(dir->i_sb, __func__,
+			ext4_warning(dir->i_sb,
 				     "dx entry: limit != node limit");
 			brelse(bh);
 			*err = ERR_BAD_DX_DIR;
@@ -505,7 +501,7 @@ fail2:
 	}
 fail:
 	if (*err == ERR_BAD_DX_DIR)
-		ext4_warning(dir->i_sb, __func__,
+		ext4_warning(dir->i_sb,
 			     "Corrupt dir inode %ld, running e2fsck is "
 			     "recommended.", dir->i_ino);
 	return NULL;
@@ -958,7 +954,7 @@ restart:
 		wait_on_buffer(bh);
 		if (!buffer_uptodate(bh)) {
 			/* read error, skip block & hope for the best */
-			ext4_error(sb, __func__, "reading directory #%lu "
+			ext4_error(sb, "reading directory #%lu "
 				   "offset %lu", dir->i_ino,
 				   (unsigned long)block);
 			brelse(bh);
@@ -1052,7 +1048,7 @@ static struct buffer_head * ext4_dx_find
 		retval = ext4_htree_next_block(dir, hash, frame,
 					       frames, NULL);
 		if (retval < 0) {
-			ext4_warning(sb, __func__,
+			ext4_warning(sb,
 			     "error reading index page in directory #%lu",
 			     dir->i_ino);
 			*err = retval;
@@ -1082,14 +1078,13 @@ static struct dentry *ext4_lookup(struct
 		__u32 ino = le32_to_cpu(de->inode);
 		brelse(bh);
 		if (!ext4_valid_inum(dir->i_sb, ino)) {
-			ext4_error(dir->i_sb, "ext4_lookup",
-				   "bad inode number: %u", ino);
+			ext4_error(dir->i_sb, "bad inode number: %u", ino);
 			return ERR_PTR(-EIO);
 		}
 		inode = ext4_iget(dir->i_sb, ino);
 		if (unlikely(IS_ERR(inode))) {
 			if (PTR_ERR(inode) == -ESTALE) {
-				ext4_error(dir->i_sb, __func__,
+				ext4_error(dir->i_sb,
 						"deleted inode referenced: %u",
 						ino);
 				return ERR_PTR(-EIO);
@@ -1121,7 +1116,7 @@ struct dentry *ext4_get_parent(struct de
 	brelse(bh);
 
 	if (!ext4_valid_inum(child->d_inode->i_sb, ino)) {
-		ext4_error(child->d_inode->i_sb, "ext4_get_parent",
+		ext4_error(child->d_inode->i_sb,
 			   "bad inode number: %u", ino);
 		return ERR_PTR(-EIO);
 	}
@@ -1421,7 +1416,7 @@ static int make_indexed_dir(handle_t *ha
 	de = (struct ext4_dir_entry_2 *)((char *)fde +
 		ext4_rec_len_from_disk(fde->rec_len, blocksize));
 	if ((char *) de >= (((char *) root) + blocksize)) {
-		ext4_error(dir->i_sb, __func__,
+		ext4_error(dir->i_sb,
 			   "invalid rec_len for '..' in inode %lu",
 			   dir->i_ino);
 		brelse(bh);
@@ -1588,7 +1583,7 @@ static int ext4_dx_add_entry(handle_t *h
 
 		if (levels && (dx_get_count(frames->entries) ==
 			       dx_get_limit(frames->entries))) {
-			ext4_warning(sb, __func__,
+			ext4_warning(sb,
 				     "Directory index full!");
 			err = -ENOSPC;
 			goto cleanup;
@@ -1944,11 +1939,11 @@ static int empty_dir(struct inode *inode
 	if (inode->i_size < EXT4_DIR_REC_LEN(1) + EXT4_DIR_REC_LEN(2) ||
 	    !(bh = ext4_bread(NULL, inode, 0, 0, &err))) {
 		if (err)
-			ext4_error(inode->i_sb, __func__,
+			ext4_error(inode->i_sb,
 				   "error %d reading directory #%lu offset 0",
 				   err, inode->i_ino);
 		else
-			ext4_warning(inode->i_sb, __func__,
+			ext4_warning(inode->i_sb,
 				     "bad directory (dir #%lu) - no data block",
 				     inode->i_ino);
 		return 1;
@@ -1959,7 +1954,7 @@ static int empty_dir(struct inode *inode
 			!le32_to_cpu(de1->inode) ||
 			strcmp(".", de->name) ||
 			strcmp("..", de1->name)) {
-		ext4_warning(inode->i_sb, "empty_dir",
+		ext4_warning(inode->i_sb,
 			     "bad directory (dir #%lu) - no `.' or `..'",
 			     inode->i_ino);
 		brelse(bh);
@@ -1977,7 +1972,7 @@ static int empty_dir(struct inode *inode
 				offset >> EXT4_BLOCK_SIZE_BITS(sb), 0, &err);
 			if (!bh) {
 				if (err)
-					ext4_error(sb, __func__,
+					ext4_error(sb,
 						   "error %d reading directory"
 						   " #%lu offset %u",
 						   err, inode->i_ino, offset);
@@ -2199,7 +2194,7 @@ static int ext4_rmdir(struct inode *dir,
 	if (retval)
 		goto end_rmdir;
 	if (!EXT4_DIR_LINK_EMPTY(inode))
-		ext4_warning(inode->i_sb, "ext4_rmdir",
+		ext4_warning(inode->i_sb,
 			     "empty directory has too many links (%d)",
 			     inode->i_nlink);
 	inode->i_version++;
@@ -2251,7 +2246,7 @@ static int ext4_unlink(struct inode *dir
 		goto end_unlink;
 
 	if (!inode->i_nlink) {
-		ext4_warning(inode->i_sb, "ext4_unlink",
+		ext4_warning(inode->i_sb,
 			     "Deleting nonexistent file (%lu), %d",
 			     inode->i_ino, inode->i_nlink);
 		inode->i_nlink = 1;
@@ -2498,7 +2493,7 @@ static int ext4_rename(struct inode *old
 		}
 	}
 	if (retval) {
-		ext4_warning(old_dir->i_sb, "ext4_rename",
+		ext4_warning(old_dir->i_sb,
 				"Deleting old file (%lu), %d, error=%d",
 				old_dir->i_ino, old_dir->i_nlink, retval);
 	}
diff -urpN linux-stage.orig/fs/ext4/resize.c linux-stage/fs/ext4/resize.c
--- linux-stage.orig/fs/ext4/resize.c	2011-06-13 11:17:46.304669000 -0400
+++ linux-stage/fs/ext4/resize.c	2011-06-13 11:29:41.324933000 -0400
@@ -48,63 +48,63 @@ static int verify_group_input(struct sup
 
 	ext4_get_group_no_and_offset(sb, start, NULL, &offset);
 	if (group != sbi->s_groups_count)
-		ext4_warning(sb, __func__,
+		ext4_warning(sb,
 			     "Cannot add at group %u (only %u groups)",
 			     input->group, sbi->s_groups_count);
 	else if (offset != 0)
-			ext4_warning(sb, __func__, "Last group not full");
+			ext4_warning(sb, "Last group not full");
 	else if (input->reserved_blocks > input->blocks_count / 5)
-		ext4_warning(sb, __func__, "Reserved blocks too high (%u)",
+		ext4_warning(sb, "Reserved blocks too high (%u)",
 			     input->reserved_blocks);
 	else if (free_blocks_count < 0)
-		ext4_warning(sb, __func__, "Bad blocks count %u",
+		ext4_warning(sb, "Bad blocks count %u",
 			     input->blocks_count);
 	else if (!(bh = sb_bread(sb, end - 1)))
-		ext4_warning(sb, __func__,
+		ext4_warning(sb,
 			     "Cannot read last block (%llu)",
 			     end - 1);
 	else if (outside(input->block_bitmap, start, end))
-		ext4_warning(sb, __func__,
+		ext4_warning(sb,
 			     "Block bitmap not in group (block %llu)",
 			     (unsigned long long)input->block_bitmap);
 	else if (outside(input->inode_bitmap, start, end))
-		ext4_warning(sb, __func__,
+		ext4_warning(sb,
 			     "Inode bitmap not in group (block %llu)",
 			     (unsigned long long)input->inode_bitmap);
 	else if (outside(input->inode_table, start, end) ||
 		 outside(itend - 1, start, end))
-		ext4_warning(sb, __func__,
+		ext4_warning(sb,
 			     "Inode table not in group (blocks %llu-%llu)",
 			     (unsigned long long)input->inode_table, itend - 1);
 	else if (input->inode_bitmap == input->block_bitmap)
-		ext4_warning(sb, __func__,
+		ext4_warning(sb,
 			     "Block bitmap same as inode bitmap (%llu)",
 			     (unsigned long long)input->block_bitmap);
 	else if (inside(input->block_bitmap, input->inode_table, itend))
-		ext4_warning(sb, __func__,
+		ext4_warning(sb,
 			     "Block bitmap (%llu) in inode table (%llu-%llu)",
 			     (unsigned long long)input->block_bitmap,
 			     (unsigned long long)input->inode_table, itend - 1);
 	else if (inside(input->inode_bitmap, input->inode_table, itend))
-		ext4_warning(sb, __func__,
+		ext4_warning(sb,
 			     "Inode bitmap (%llu) in inode table (%llu-%llu)",
 			     (unsigned long long)input->inode_bitmap,
 			     (unsigned long long)input->inode_table, itend - 1);
 	else if (inside(input->block_bitmap, start, metaend))
-		ext4_warning(sb, __func__,
+		ext4_warning(sb,
 			     "Block bitmap (%llu) in GDT table"
 			     " (%llu-%llu)",
 			     (unsigned long long)input->block_bitmap,
 			     start, metaend - 1);
 	else if (inside(input->inode_bitmap, start, metaend))
-		ext4_warning(sb, __func__,
+		ext4_warning(sb,
 			     "Inode bitmap (%llu) in GDT table"
 			     " (%llu-%llu)",
 			     (unsigned long long)input->inode_bitmap,
 			     start, metaend - 1);
 	else if (inside(input->inode_table, start, metaend) ||
 		 inside(itend - 1, start, metaend))
-		ext4_warning(sb, __func__,
+		ext4_warning(sb,
 			     "Inode table (%llu-%llu) overlaps"
 			     "GDT table (%llu-%llu)",
 			     (unsigned long long)input->inode_table,
@@ -364,7 +364,7 @@ static int verify_reserved_gdb(struct su
 	while ((grp = ext4_list_backups(sb, &three, &five, &seven)) < end) {
 		if (le32_to_cpu(*p++) !=
 		    grp * EXT4_BLOCKS_PER_GROUP(sb) + blk){
-			ext4_warning(sb, __func__,
+			ext4_warning(sb,
 				     "reserved GDT %llu"
 				     " missing grp %d (%llu)",
 				     blk, grp,
@@ -420,7 +420,7 @@ static int add_new_gdb(handle_t *handle,
          */
 	if (EXT4_SB(sb)->s_sbh->b_blocknr !=
 	    le32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block)) {
-		ext4_warning(sb, __func__,
+		ext4_warning(sb,
 			"won't resize using backup superblock at %llu",
 			(unsigned long long)EXT4_SB(sb)->s_sbh->b_blocknr);
 		return -EPERM;
@@ -444,7 +444,7 @@ static int add_new_gdb(handle_t *handle,
 
 	data = (__le32 *)dind->b_data;
 	if (le32_to_cpu(data[gdb_num % EXT4_ADDR_PER_BLOCK(sb)]) != gdblock) {
-		ext4_warning(sb, __func__,
+		ext4_warning(sb,
 			     "new group %u GDT block %llu not reserved",
 			     input->group, gdblock);
 		err = -EINVAL;
@@ -468,7 +468,7 @@ static int add_new_gdb(handle_t *handle,
 			GFP_NOFS);
 	if (!n_group_desc) {
 		err = -ENOMEM;
-		ext4_warning(sb, __func__,
+		ext4_warning(sb,
 			      "not enough memory for %lu groups", gdb_num + 1);
 		goto exit_inode;
 	}
@@ -567,7 +567,7 @@ static int reserve_backup_gdb(handle_t *
 	/* Get each reserved primary GDT block and verify it holds backups */
 	for (res = 0; res < reserved_gdb; res++, blk++) {
 		if (le32_to_cpu(*data) != blk) {
-			ext4_warning(sb, __func__,
+			ext4_warning(sb,
 				     "reserved block %llu"
 				     " not at offset %ld",
 				     blk,
@@ -713,7 +713,7 @@ static void update_backups(struct super_
 	 */
 exit_err:
 	if (err) {
-		ext4_warning(sb, __func__,
+		ext4_warning(sb,
 			     "can't update backup for group %u (err %d), "
 			     "forcing fsck on next reboot", group, err);
 		sbi->s_mount_state &= ~EXT4_VALID_FS;
@@ -753,20 +753,20 @@ int ext4_group_add(struct super_block *s
 
 	if (gdb_off == 0 && !EXT4_HAS_RO_COMPAT_FEATURE(sb,
 					EXT4_FEATURE_RO_COMPAT_SPARSE_SUPER)) {
-		ext4_warning(sb, __func__,
+		ext4_warning(sb,
 			     "Can't resize non-sparse filesystem further");
 		return -EPERM;
 	}
 
 	if (ext4_blocks_count(es) + input->blocks_count <
 	    ext4_blocks_count(es)) {
-		ext4_warning(sb, __func__, "blocks_count overflow");
+		ext4_warning(sb, "blocks_count overflow");
 		return -EINVAL;
 	}
 
 	if (le32_to_cpu(es->s_inodes_count) + EXT4_INODES_PER_GROUP(sb) <
 	    le32_to_cpu(es->s_inodes_count)) {
-		ext4_warning(sb, __func__, "inodes_count overflow");
+		ext4_warning(sb, "inodes_count overflow");
 		return -EINVAL;
 	}
 
@@ -774,13 +774,13 @@ int ext4_group_add(struct super_block *s
 		if (!EXT4_HAS_COMPAT_FEATURE(sb,
 					     EXT4_FEATURE_COMPAT_RESIZE_INODE)
 		    || !le16_to_cpu(es->s_reserved_gdt_blocks)) {
-			ext4_warning(sb, __func__,
+			ext4_warning(sb,
 				     "No reserved GDT blocks, can't resize");
 			return -EPERM;
 		}
 		inode = ext4_iget(sb, EXT4_RESIZE_INO);
 		if (IS_ERR(inode)) {
-			ext4_warning(sb, __func__,
+			ext4_warning(sb,
 				     "Error opening resize inode");
 			return PTR_ERR(inode);
 		}
@@ -810,7 +810,7 @@ int ext4_group_add(struct super_block *s
 
 	mutex_lock(&sbi->s_resize_lock);
 	if (input->group != sbi->s_groups_count) {
-		ext4_warning(sb, __func__,
+		ext4_warning(sb,
 			     "multiple resizers run on filesystem!");
 		err = -EBUSY;
 		goto exit_journal;
@@ -998,12 +998,12 @@ int ext4_group_extend(struct super_block
 			" too large to resize to %llu blocks safely\n",
 			sb->s_id, n_blocks_count);
 		if (sizeof(sector_t) < 8)
-			ext4_warning(sb, __func__, "CONFIG_LBDAF not enabled");
+			ext4_warning(sb, "CONFIG_LBDAF not enabled");
 		return -EINVAL;
 	}
 
 	if (n_blocks_count < o_blocks_count) {
-		ext4_warning(sb, __func__,
+		ext4_warning(sb,
 			     "can't shrink FS - resize aborted");
 		return -EBUSY;
 	}
@@ -1012,7 +1012,7 @@ int ext4_group_extend(struct super_block
 	ext4_get_group_no_and_offset(sb, o_blocks_count, &group, &last);
 
 	if (last == 0) {
-		ext4_warning(sb, __func__,
+		ext4_warning(sb,
 			     "need to use ext2online to resize further");
 		return -EPERM;
 	}
@@ -1020,7 +1020,7 @@ int ext4_group_extend(struct super_block
 	add = EXT4_BLOCKS_PER_GROUP(sb) - last;
 
 	if (o_blocks_count + add < o_blocks_count) {
-		ext4_warning(sb, __func__, "blocks_count overflow");
+		ext4_warning(sb, "blocks_count overflow");
 		return -EINVAL;
 	}
 
@@ -1028,7 +1028,7 @@ int ext4_group_extend(struct super_block
 		add = n_blocks_count - o_blocks_count;
 
 	if (o_blocks_count + add < n_blocks_count)
-		ext4_warning(sb, __func__,
+		ext4_warning(sb,
 			     "will only finish group (%llu"
 			     " blocks, %u new)",
 			     o_blocks_count + add, add);
@@ -1036,7 +1036,7 @@ int ext4_group_extend(struct super_block
 	/* See if the device is actually as big as what was requested */
 	bh = sb_bread(sb, o_blocks_count + add - 1);
 	if (!bh) {
-		ext4_warning(sb, __func__,
+		ext4_warning(sb,
 			     "can't read last block, resize aborted");
 		return -ENOSPC;
 	}
@@ -1048,13 +1048,13 @@ int ext4_group_extend(struct super_block
 	handle = ext4_journal_start_sb(sb, 3);
 	if (IS_ERR(handle)) {
 		err = PTR_ERR(handle);
-		ext4_warning(sb, __func__, "error %d on journal start", err);
+		ext4_warning(sb, "error %d on journal start", err);
 		goto exit_put;
 	}
 
 	mutex_lock(&EXT4_SB(sb)->s_resize_lock);
 	if (o_blocks_count != ext4_blocks_count(es)) {
-		ext4_warning(sb, __func__,
+		ext4_warning(sb,
 			     "multiple resizers run on filesystem!");
 		mutex_unlock(&EXT4_SB(sb)->s_resize_lock);
 		ext4_journal_stop(handle);
@@ -1064,7 +1064,7 @@ int ext4_group_extend(struct super_block
 
 	if ((err = ext4_journal_get_write_access(handle,
 						 EXT4_SB(sb)->s_sbh))) {
-		ext4_warning(sb, __func__,
+		ext4_warning(sb,
 			     "error %d on journal write access", err);
 		mutex_unlock(&EXT4_SB(sb)->s_resize_lock);
 		ext4_journal_stop(handle);
diff -urpN linux-stage.orig/fs/ext4/super.c linux-stage/fs/ext4/super.c
--- linux-stage.orig/fs/ext4/super.c	2011-06-13 11:17:46.536437000 -0400
+++ linux-stage/fs/ext4/super.c	2011-06-13 11:29:41.373884000 -0400
@@ -337,7 +337,7 @@ static void ext4_handle_error(struct sup
 			sb->s_id);
 }
 
-void ext4_error(struct super_block *sb, const char *function,
+void __ext4_error(struct super_block *sb, const char *function,
 		const char *fmt, ...)
 {
 	va_list args;
@@ -454,7 +454,7 @@ void ext4_msg (struct super_block * sb, 
 	va_end(args);
 }
 
-void ext4_warning(struct super_block *sb, const char *function,
+void __ext4_warning(struct super_block *sb, const char *function,
 		  const char *fmt, ...)
 {
 	va_list args;
@@ -511,7 +511,7 @@ void ext4_update_dynamic_rev(struct supe
 	if (le32_to_cpu(es->s_rev_level) > EXT4_GOOD_OLD_REV)
 		return;
 
-	ext4_warning(sb, __func__,
+	ext4_warning(sb,
 		     "updating to rev %d because of new feature flag, "
 		     "running e2fsck is recommended",
 		     EXT4_DYNAMIC_REV);
@@ -1096,9 +1096,9 @@ enum {
 	Opt_abort, Opt_data_journal, Opt_data_ordered, Opt_data_writeback,
 	Opt_data_err_abort, Opt_data_err_ignore,
 	Opt_usrjquota, Opt_grpjquota, Opt_offusrjquota, Opt_offgrpjquota,
-	Opt_jqfmt_vfsold, Opt_jqfmt_vfsv0, Opt_quota, Opt_noquota,
-	Opt_ignore, Opt_barrier, Opt_nobarrier, Opt_err, Opt_resize,
-	Opt_usrquota, Opt_grpquota, Opt_i_version,
+	Opt_jqfmt_vfsold, Opt_jqfmt_vfsv0, Opt_jqfmt_vfsv1, Opt_quota,
+	Opt_noquota, Opt_ignore, Opt_barrier, Opt_nobarrier, Opt_err,
+	Opt_resize, Opt_usrquota, Opt_grpquota, Opt_i_version,
 	Opt_stripe, Opt_delalloc, Opt_nodelalloc,
 	Opt_block_validity, Opt_noblock_validity,
 	Opt_inode_readahead_blks, Opt_journal_ioprio,
@@ -2709,6 +2709,21 @@ static int ext4_fill_super(struct super_
 	get_random_bytes(&sbi->s_next_generation, sizeof(u32));
 	spin_lock_init(&sbi->s_next_gen_lock);
 
+	err = percpu_counter_init(&sbi->s_freeblocks_counter,
+				  ext4_count_free_blocks(sb));
+	if (!err)
+		err = percpu_counter_init(&sbi->s_freeinodes_counter,
+					  ext4_count_free_inodes(sb));
+	if (!err)
+		err = percpu_counter_init(&sbi->s_dirs_counter,
+					  ext4_count_dirs(sb));
+	if (!err)
+		err = percpu_counter_init(&sbi->s_dirtyblocks_counter, 0);
+	if (err) {
+		ext4_msg(sb, KERN_ERR, "insufficient memory");
+		goto failed_mount3;
+	}
+
 	sbi->s_stripe = ext4_get_stripe_size(sbi);
 	sbi->s_max_writeback_mb_bump = 128;
 
@@ -2828,20 +2843,6 @@ static int ext4_fill_super(struct super_
 	set_task_ioprio(sbi->s_journal->j_task, journal_ioprio);
 
 no_journal:
-	err = percpu_counter_init(&sbi->s_freeblocks_counter,
-				  ext4_count_free_blocks(sb));
-	if (!err)
-		err = percpu_counter_init(&sbi->s_freeinodes_counter,
-					  ext4_count_free_inodes(sb));
-	if (!err)
-		err = percpu_counter_init(&sbi->s_dirs_counter,
-					  ext4_count_dirs(sb));
-	if (!err)
-		err = percpu_counter_init(&sbi->s_dirtyblocks_counter, 0);
-	if (err) {
-		ext4_msg(sb, KERN_ERR, "insufficient memory");
-		goto failed_mount_wq;
-	}
 	if (test_opt(sb, NOBH)) {
 		if (!(test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_WRITEBACK_DATA)) {
 			ext4_msg(sb, KERN_WARNING, "Ignoring nobh option - "
@@ -2974,10 +2975,6 @@ failed_mount_wq:
 		jbd2_journal_destroy(sbi->s_journal);
 		sbi->s_journal = NULL;
 	}
-	percpu_counter_destroy(&sbi->s_freeblocks_counter);
-	percpu_counter_destroy(&sbi->s_freeinodes_counter);
-	percpu_counter_destroy(&sbi->s_dirs_counter);
-	percpu_counter_destroy(&sbi->s_dirtyblocks_counter);
 failed_mount3:
 	if (sbi->s_flex_groups) {
 		if (is_vmalloc_addr(sbi->s_flex_groups))
@@ -2985,6 +2982,10 @@ failed_mount3:
 		else
 			kfree(sbi->s_flex_groups);
 	}
+	percpu_counter_destroy(&sbi->s_freeblocks_counter);
+	percpu_counter_destroy(&sbi->s_freeinodes_counter);
+	percpu_counter_destroy(&sbi->s_dirs_counter);
+	percpu_counter_destroy(&sbi->s_dirtyblocks_counter);
 failed_mount2:
 	for (i = 0; i < db_count; i++)
 		brelse(sbi->s_group_desc[i]);
@@ -3377,9 +3378,9 @@ static void ext4_clear_journal_err(struc
 		char nbuf[16];
 
 		errstr = ext4_decode_error(sb, j_errno, nbuf);
-		ext4_warning(sb, __func__, "Filesystem error recorded "
+		ext4_warning(sb, "Filesystem error recorded "
 			     "from previous mount: %s", errstr);
-		ext4_warning(sb, __func__, "Marking fs in need of "
+		ext4_warning(sb, "Marking fs in need of "
 			     "filesystem check.");
 
 		EXT4_SB(sb)->s_mount_state |= EXT4_ERROR_FS;
diff -urpN linux-stage.orig/fs/ext4/xattr.c linux-stage/fs/ext4/xattr.c
--- linux-stage.orig/fs/ext4/xattr.c	2011-06-13 11:17:46.313660000 -0400
+++ linux-stage/fs/ext4/xattr.c	2011-06-13 11:29:41.450805000 -0400
@@ -227,7 +227,7 @@ ext4_xattr_block_get(struct inode *inode
 	ea_bdebug(bh, "b_count=%d, refcount=%d",
 		atomic_read(&(bh->b_count)), le32_to_cpu(BHDR(bh)->h_refcount));
 	if (ext4_xattr_check_block(bh)) {
-bad_block:	ext4_error(inode->i_sb, __func__,
+bad_block:	ext4_error(inode->i_sb,
 			   "inode %lu: bad block %llu", inode->i_ino,
 			   EXT4_I(inode)->i_file_acl);
 		error = -EIO;
@@ -369,7 +369,7 @@ ext4_xattr_block_list(struct inode *inod
 	ea_bdebug(bh, "b_count=%d, refcount=%d",
 		atomic_read(&(bh->b_count)), le32_to_cpu(BHDR(bh)->h_refcount));
 	if (ext4_xattr_check_block(bh)) {
-		ext4_error(inode->i_sb, __func__,
+		ext4_error(inode->i_sb,
 			   "inode %lu: bad block %llu", inode->i_ino,
 			   EXT4_I(inode)->i_file_acl);
 		error = -EIO;
@@ -661,7 +661,7 @@ ext4_xattr_block_find(struct inode *inod
 			atomic_read(&(bs->bh->b_count)),
 			le32_to_cpu(BHDR(bs->bh)->h_refcount));
 		if (ext4_xattr_check_block(bs->bh)) {
-			ext4_error(sb, __func__,
+			ext4_error(sb,
 				"inode %lu: bad block %llu", inode->i_ino,
 				EXT4_I(inode)->i_file_acl);
 			error = -EIO;
@@ -875,7 +875,7 @@ cleanup_dquot:
 	goto cleanup;
 
 bad_block:
-	ext4_error(inode->i_sb, __func__,
+	ext4_error(inode->i_sb,
 		   "inode %lu: bad block %llu", inode->i_ino,
 		   EXT4_I(inode)->i_file_acl);
 	goto cleanup;
@@ -1190,7 +1190,7 @@ retry:
 		if (!bh)
 			goto cleanup;
 		if (ext4_xattr_check_block(bh)) {
-			ext4_error(inode->i_sb, __func__,
+			ext4_error(inode->i_sb,
 				"inode %lu: bad block %llu", inode->i_ino,
 				EXT4_I(inode)->i_file_acl);
 			error = -EIO;
@@ -1367,14 +1367,14 @@ ext4_xattr_delete_inode(handle_t *handle
 		goto cleanup;
 	bh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);
 	if (!bh) {
-		ext4_error(inode->i_sb, __func__,
+		ext4_error(inode->i_sb,
 			"inode %lu: block %llu read error", inode->i_ino,
 			EXT4_I(inode)->i_file_acl);
 		goto cleanup;
 	}
 	if (BHDR(bh)->h_magic != cpu_to_le32(EXT4_XATTR_MAGIC) ||
 	    BHDR(bh)->h_blocks != cpu_to_le32(1)) {
-		ext4_error(inode->i_sb, __func__,
+		ext4_error(inode->i_sb,
 			"inode %lu: bad block %llu", inode->i_ino,
 			EXT4_I(inode)->i_file_acl);
 		goto cleanup;
@@ -1501,7 +1501,7 @@ again:
 		}
 		bh = sb_bread(inode->i_sb, ce->e_block);
 		if (!bh) {
-			ext4_error(inode->i_sb, __func__,
+			ext4_error(inode->i_sb,
 				"inode %lu: block %lu read error",
 				inode->i_ino, (unsigned long) ce->e_block);
 		} else if (le32_to_cpu(BHDR(bh)->h_refcount) >=
