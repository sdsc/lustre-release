diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index 343d539..e6d0602 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -1187,6 +1187,7 @@ struct ext4_sb_info {
 	unsigned int s_mb_group_prealloc;
 	unsigned int s_max_writeback_mb_bump;
 	unsigned long s_max_dir_size;
+	unsigned long s_warning_dir_size;
 	/* where last allocation was done - for stream allocation */
 	unsigned long s_mb_last_group;
 	unsigned long s_mb_last_start;
diff --git a/fs/ext4/namei.c b/fs/ext4/namei.c
index 523f9ad..30415cd 100644
--- a/fs/ext4/namei.c
+++ b/fs/ext4/namei.c
@@ -2033,7 +2033,8 @@ int ext4_add_entry(handle_t *handle, struct dentry *dentry,
 		    memcmp(dentry->d_name.name, "..", 2) == 0)
 			return ext4_update_dotdot(handle, dentry, inode);
 		retval = ext4_dx_add_entry(handle, dentry, inode, lck);
-		if (!retval || (retval != ERR_BAD_DX_DIR))
+		if (!retval || (retval != ERR_BAD_DX_DIR) ||
+		    (retval != -ENOBUFS))
 			return retval;
 		ext4_htree_safe_relock(lck);
 		ext4_clear_inode_flag(dir, EXT4_INODE_INDEX);
@@ -2068,6 +2069,52 @@ int ext4_add_entry(handle_t *handle, struct dentry *dentry,
 }
 EXPORT_SYMBOL(ext4_add_entry);
 
+static unsigned long __ext4_max_dir_size(struct dx_frame *frames,
+			       struct dx_frame *frame, struct inode *dir)
+{
+	unsigned long max_dir_size;
+
+	if (EXT4_SB(dir->i_sb)->s_max_dir_size) {
+		max_dir_size = EXT4_SB(dir->i_sb)->s_max_dir_size;
+	} else {
+		max_dir_size = EXT4_BLOCK_SIZE(dir->i_sb);
+		while (frame >= frames) {
+			max_dir_size *= dx_get_limit(frame->entries);
+			if (frame == frames)
+				break;
+			frame--;
+		}
+		/* use 75% of max dir size in average */
+		max_dir_size = max_dir_size / 4 * 3;
+	}
+	return max_dir_size;
+}
+
+/*
+ * With hash tree growing, it is easy to hit ENOSPC, but it is hard
+ * to predict when it will happen. let's give administrators warning
+ * when reaching 50% and 75% of limit
+ */
+static inline bool dir_size_in_warning_range(struct dx_frame *frames,
+					     struct dx_frame *frame,
+					     struct inode *dir)
+{
+	unsigned long size1, size2;
+	struct super_block *sb = dir->i_sb;
+
+	if (!EXT4_SB(sb)->s_warning_dir_size)
+		EXT4_SB(sb)->s_warning_dir_size =
+				__ext4_max_dir_size(frames, frame, dir);
+
+	size1 = EXT4_SB(sb)->s_warning_dir_size / 2;
+	size2 = EXT4_SB(sb)->s_warning_dir_size / 4 * 3;
+	if (in_range(dir->i_size, size1, EXT4_BLOCK_SIZE(sb)) ||
+	    in_range(dir->i_size, size2, EXT4_BLOCK_SIZE(sb)))
+		return true;
+
+	return false;
+}
+
 /*
  * Returns 0 for success, or a negative error value
  */
@@ -2083,6 +2130,7 @@ static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,
 	struct ext4_dir_entry_2 *de;
 	int restart;
 	int err;
+	bool ret_warn = false;
 
 again:
 	restart = 0;
@@ -2103,6 +2151,10 @@ again:
 	/* Block full, should compress but for now just split */
 	dxtrace(printk(KERN_DEBUG "using %u of %u node entries\n",
 		       dx_get_count(entries), dx_get_limit(entries)));
+
+	if (frame - frames + 1 >= ext4_dir_htree_level(sb))
+		ret_warn = dir_size_in_warning_range(frames, frame, dir);
+
 	/* Need to split index? */
 	if (dx_get_count(entries) == dx_get_limit(entries)) {
 		ext4_lblk_t newblock;
@@ -2134,7 +2186,7 @@ again:
 					 "reach max htree level :%d",
 					 dir->i_ino, levels);
 			if (ext4_dir_htree_level(sb) < EXT4_HTREE_LEVEL) {
-				ext4_warning(sb, "Large directory feature is"
+				ext4_warning(sb, "Large directory feature is "
 						 "not enabled on this "
 						 "filesystem");
 			}
@@ -2259,6 +2311,8 @@ cleanup:
 	 * repeat dx_probe() to find out valid htree-path */
 	if (restart && err == 0)
 		goto again;
+	if (err == 0 && ret_warn)
+		err = -ENOBUFS;
 	return err;
 }
 
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index 676a645..9063fce 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -1793,6 +1793,8 @@ set_qf_format:
 			if (option < 0)
 				return 0;
 			sbi->s_max_dir_size = option * 1024;
+			/* reset s_warning_dir_size and make it re-calculated */
+			sbi->s_warning_dir_size = 0;
 			break;
 		case Opt_stripe:
 			if (match_int(&args[0], &option))
@@ -2557,6 +2559,7 @@ EXT4_ATTR_OFFSET(inode_readahead_blks, 0644, sbi_ui_show,
 		 inode_readahead_blks_store, s_inode_readahead_blks);
 EXT4_RW_ATTR_SBI_UI(inode_goal, s_inode_goal);
 EXT4_RW_ATTR_SBI_UI(max_dir_size, s_max_dir_size);
+EXT4_RW_ATTR_SBI_UI(warning_dir_size, s_warning_dir_size);
 EXT4_RW_ATTR_SBI_UI(mb_stats, s_mb_stats);
 EXT4_RW_ATTR_SBI_UI(mb_max_to_scan, s_mb_max_to_scan);
 EXT4_RW_ATTR_SBI_UI(mb_min_to_scan, s_mb_min_to_scan);
@@ -2574,6 +2577,7 @@ static struct attribute *ext4_attrs[] = {
 	ATTR_LIST(inode_readahead_blks),
 	ATTR_LIST(inode_goal),
 	ATTR_LIST(max_dir_size),
+	ATTR_LIST(warning_dir_size),
 	ATTR_LIST(mb_stats),
 	ATTR_LIST(mb_max_to_scan),
 	ATTR_LIST(mb_min_to_scan),
@@ -3099,6 +3103,7 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)
 	sb->s_fs_info = sbi;
 	sbi->s_mount_opt = 0;
 	sbi->s_max_dir_size = 0;
+	sbi->s_warning_dir_size = 0;
 	sbi->s_resuid = EXT4_DEF_RESUID;
 	sbi->s_resgid = EXT4_DEF_RESGID;
 	sbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;
