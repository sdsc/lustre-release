diff --git a/fs/ext4/namei.c b/fs/ext4/namei.c
index b14034b..cc29496 100644
--- a/fs/ext4/namei.c
+++ b/fs/ext4/namei.c
@@ -2018,7 +2018,8 @@ int __ext4_add_entry(handle_t *handle, struct dentry *dentry,
 		    memcmp(dentry->d_name.name, "..", 2) == 0)
 			return ext4_update_dotdot(handle, dentry, inode);
 		retval = ext4_dx_add_entry(handle, dentry, inode, lck);
-		if (!retval || (retval != ERR_BAD_DX_DIR))
+		if (!retval || (retval != ERR_BAD_DX_DIR) ||
+		    (retval != -ENOBUFS))
 			return retval;
 		ext4_htree_safe_relock(lck);
 		ext4_clear_inode_flag(dir, EXT4_INODE_INDEX);
@@ -2053,6 +2054,50 @@ int __ext4_add_entry(handle_t *handle, struct dentry *dentry,
 }
 EXPORT_SYMBOL(__ext4_add_entry);
 
+static u64 __ext4_max_dir_size(struct dx_frame *frames,
+			       struct dx_frame *frame, struct inode *dir)
+{
+	u64 max_dir_size = EXT4_BLOCK_SIZE(dir->i_sb);
+
+	if (EXT4_SB(dir->i_sb)->s_max_dir_size) {
+		max_dir_size = EXT4_SB(dir->i_sb)->s_max_dir_size;
+	} else {
+		while (frame >= frames) {
+			max_dir_size *= dx_get_limit(frame->entries);
+			if (frame == frames)
+				break;
+			frame--;
+		}
+	}
+	return max_dir_size;
+}
+
+/*
+ * With hash tree growing, it is easy to hit ENOSPC, but it is hard
+ * to predict when it will happen. let's give administrators warning
+ * when reaching 50% and 75% of limit
+ */
+static inline bool dir_size_in_warning_range(struct dx_frame *frames,
+					     struct dx_frame *frame,
+					     struct inode *dir)
+{
+	
+	u64 size1, size2;
+	u64 max_dir_size = __ext4_max_dir_size(frames, frame, dir);
+	struct super_block *sb = dir->i_sb;
+
+	max_dir_size = max_dir_size / 4 * 3;
+	size1 = max_dir_size / 2;
+	size2 = max_dir_size / 4 * 3;
+	if ((dir->i_size >= size1 &&
+	     dir->i_size - size1 < EXT4_BLOCK_SIZE(sb))
+	    || (dir->i_size >= size2 &&
+		dir->i_size - size2 < EXT4_BLOCK_SIZE(sb)))
+		return true;
+
+	return false;
+}
+
 /*
  * Returns 0 for success, or a negative error value
  */
@@ -2068,6 +2113,7 @@ static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,
 	struct ext4_dir_entry_2 *de;
 	int restart;
 	int err;
+	bool ret_warn = false;
 
 again:
 	restart = 0;
@@ -2088,6 +2134,10 @@ again:
 	/* Block full, should compress but for now just split */
 	dxtrace(printk(KERN_DEBUG "using %u of %u node entries\n",
 		       dx_get_count(entries), dx_get_limit(entries)));
+
+	if (frame - frames + 1 >= ext4_dir_htree_level(sb))
+		ret_warn = dir_size_in_warning_range(frames, frame, dir);
+
 	/* Need to split index? */
 	if (dx_get_count(entries) == dx_get_limit(entries)) {
 		ext4_lblk_t newblock;
@@ -2119,7 +2169,7 @@ again:
 					 "reach max htree level :%d",
 					 dir->i_ino, levels);
 			if (ext4_dir_htree_level(sb) < EXT4_HTREE_LEVEL) {
-				ext4_warning(sb, "Large directory feature is"
+				ext4_warning(sb, "Large directory feature is "
 						 "not enabled on this "
 						 "filesystem");
 			}
@@ -2248,6 +2298,8 @@ cleanup:
 	 * repeat dx_probe() to find out valid htree-path */
 	if (restart && err == 0)
 		goto again;
+	if (err == 0 && ret_warn)
+		err = -ENOBUFS;
 	return err;
 }
 
