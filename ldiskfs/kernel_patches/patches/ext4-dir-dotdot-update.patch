Index: linux-stage/fs/ext4/namei.c
===================================================================
--- linux-stage.orig/fs/ext4/namei.c
+++ linux-stage/fs/ext4/namei.c
@@ -1889,6 +1889,164 @@ static int make_indexed_dir(handle_t *ha
 	return retval;
 }
 
+static int ext4_update_dotdot(handle_t *handle, struct dentry *dentry,
+			      struct inode *inode)
+{
+	struct inode *dir = dentry->d_parent->d_inode;
+	struct super_block *sb = dir->i_sb;
+	struct buffer_head *bh, *bh2;
+	struct ext4_dir_entry_2 *de, *de2;
+	int need, len, len2, dlen = 0, err = 0, size = 0, level = 0, dis = 0;
+	struct dx_root_info *info;
+	struct dx_entry *entries, *entries2;
+	struct dx_node *node;
+	char *data;
+	ext4_lblk_t block = 0;
+	unsigned blocksize = sb->s_blocksize;
+
+	if (IS_DIRSYNC(dir))
+		handle->h_sync = 1;
+
+	data = ext4_dentry_get_data(sb,
+			(struct ext4_dentry_param *)dentry->d_fsdata);
+	if (data != NULL)
+		dlen = *data + 1;
+	need = __EXT4_DIR_REC_LEN(2 + dlen);
+
+	bh = ext4_bread(handle, dir, 0, 0, &err);
+	if (bh == NULL)
+		return err;
+
+	BUFFER_TRACE(bh, "get_write_access");
+	err = ext4_journal_get_write_access(handle, bh);
+	if (err != 0)
+		goto out;
+
+	de = (struct ext4_dir_entry_2 *)bh->b_data;
+	/* The first item must be "." */
+	assert(de->name_len == 1 && de->name[0] == '.');
+
+	de2 = (struct ext4_dir_entry_2 *)((char *)de +
+					  EXT4_DIR_REC_LEN(de));
+	/* ".." entry has ever been there. */
+	assert(de2->name_len == 2 && memcmp(de2->name, "..", 2) == 0);
+
+	len = ext4_rec_len_from_disk(de->rec_len, blocksize);
+	len2 = ext4_rec_len_from_disk(de2->rec_len, blocksize);
+	if (len2 == 0) {
+		assert(len >= (EXT4_DIR_REC_LEN(de) +
+			       EXT4_DIR_REC_LEN(de2)));
+		/* split "." enrty */
+		de->rec_len = ext4_rec_len_to_disk(EXT4_DIR_REC_LEN(de),
+						   blocksize);
+		len2 = len - EXT4_DIR_REC_LEN(de);
+	} else {
+		assert(len == EXT4_DIR_REC_LEN(de));
+		assert(len2 >= EXT4_DIR_REC_LEN(de2));
+	}
+
+	if (is_dx(dir)) {
+		/* Dx root info is after ".." entry. */
+		info = (struct dx_root_info *)((char *)de2 +
+					       EXT4_DIR_REC_LEN(de2));
+		entries = (struct dx_entry *)((char *)info + info->info_length);
+		size = info->info_length +
+		       dx_get_count(entries) * sizeof(struct dx_entry);
+		dis = (char *)de2 + need - (char *)info;
+	}
+
+	if (len2 >= need)
+		goto update;
+
+	/* Normally, non-empty directory should be dx mode. If not, add
+	 * ".." entry back without data (for FID-in-dirent) appended. */
+	if (!is_dx(dir)) {
+		data = NULL;
+		goto update;
+	}
+
+	if ((EXT4_DIR_REC_LEN(de) + need + size) <= blocksize)
+		goto update;
+
+	/* The index is full, add ".." backup without data appended. */
+	if (info->indirect_levels == ext4_dir_htree_level(sb)) {
+		err = -ENOSPC;
+		data = NULL;
+		dis -= dlen;
+		goto update;
+	}
+
+	bh2 = ext4_append(handle, dir, &block, &err);
+	if (bh2 == NULL) {
+		/* Keep the directory availability is more important. */
+		data = NULL;
+		dis -= dlen;
+		goto update;
+	}
+
+	node = (struct dx_node *)(bh2->b_data);
+	entries2 = node->entries;
+	memset(&node->fake, 0, sizeof(struct fake_dirent));
+	node->fake.rec_len = ext4_rec_len_to_disk(blocksize, blocksize);
+	memcpy((char *)entries2, (char *)entries, size);
+	dx_set_limit(entries2, dx_node_limit(dir));
+	BUFFER_TRACE(bh2, "call ext4_handle_dirty_metadata");
+	err = ext4_handle_dirty_metadata(handle, dir, bh2);
+	brelse(bh2);
+	if (err != 0) {
+		/* Keep the directory availability is more important. */
+		data = NULL;
+		dis -= dlen;
+		goto update;
+	}
+
+	size = info->info_length;
+	level = 1;
+
+update:
+	de2->inode = cpu_to_le32(inode->i_ino);
+	if (is_dx(dir)) {
+		de2->rec_len =
+			ext4_rec_len_to_disk(
+				blocksize - EXT4_DIR_REC_LEN(de), blocksize);
+
+		if (dis != 0) {
+			assert(size != 0);
+			memmove((char *)info + dis, info, size);
+			info = (struct dx_root_info *)((char *)info + dis);
+			entries = (struct dx_entry *)((char *)info +
+						      info->info_length);
+		}
+
+		if (level != 0) {
+			info->indirect_levels += level;
+			dx_set_block(entries, block);
+			dx_set_count(entries, 1);
+			dx_set_limit(entries, dx_root_limit(blocksize, de,
+							    info->info_length));
+		}
+	} else {
+		de2->rec_len = ext4_rec_len_to_disk(len2, blocksize);
+	}
+
+	if (data != NULL) {
+		de2->name[2] = 0;
+		memcpy(&de2->name[3], data, dlen);
+		de2->file_type |= EXT4_DIRENT_LUFID;
+	} else if (dlen != 0) {
+		ext4_warning(sb, "Updated .. with %d bytes data dropped "
+			     "err = %d", dlen, err);
+	}
+
+	BUFFER_TRACE(bh, "call ext4_handle_dirty_metadata");
+	err = ext4_handle_dirty_metadata(handle, dir, bh);
+	ext4_mark_inode_dirty(handle, dir);
+
+out:
+	brelse(bh);
+	return err;
+}
+
 /*
  *	ext4_add_entry()
  *
@@ -1915,6 +2073,11 @@ int ext4_add_entry(handle_t *handle, str
 	blocksize = sb->s_blocksize;
 	if (!dentry->d_name.len)
 		return -EINVAL;
+
+	if (unlikely(dentry->d_name.len == 2 &&
+		     memcmp(dentry->d_name.name, "..", 2) == 0))
+		return ext4_update_dotdot(handle, dentry, inode);
+
 	if (is_dx(dir)) {
 		retval = ext4_dx_add_entry(handle, dentry, inode, lck);
 		if (!retval || (retval != ERR_BAD_DX_DIR))
