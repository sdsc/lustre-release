Index: linux-3.10.0-123.13.2.el7.x86_64/fs/ext4/ext4.h
===================================================================
--- linux-3.10.0-123.13.2.el7.x86_64.orig/fs/ext4/ext4.h
+++ linux-3.10.0-123.13.2.el7.x86_64/fs/ext4/ext4.h
@@ -1427,6 +1427,10 @@ static inline void ext4_clear_state_flag
 
 #define NEXT_ORPHAN(inode) EXT4_I(inode)->i_dtime

+/* Has been moved to linux/magic.h but we need it for ldiskfs */
+#define EXT4_SUPER_MAGIC      0xEF53
+#define JOURNAL_START_HAS_3ARGS	1
+
 /*
  * Codes for operating systems
  */
@@ -2612,6 +2614,8 @@ struct ext4_extent;
 
 extern int ext4_ext_tree_init(handle_t *handle, struct inode *);
 extern int ext4_ext_writepage_trans_blocks(struct inode *, int);
+extern struct buffer_head *ext4_read_inode_bitmap(struct super_block *sb,
+						  ext4_group_t block_group);
 extern int ext4_ext_index_trans_blocks(struct inode *inode, int nrblocks,
 				       int chunk);
 extern int ext4_ext_map_blocks(handle_t *handle, struct inode *inode,
Index: linux-3.10.0-123.13.2.el7.x86_64/fs/ext4/ext4_jbd2.c
===================================================================
--- linux-3.10.0-123.13.2.el7.x86_64.orig/fs/ext4/ext4_jbd2.c
+++ linux-3.10.0-123.13.2.el7.x86_64/fs/ext4/ext4_jbd2.c
@@ -34,6 +34,7 @@ static void ext4_put_nojournal(handle_t
 
 	current->journal_info = handle;
 }
+EXPORT_SYMBOL(__ext4_journal_get_write_access);
 
 /*
  * Wrappers for jbd2_journal_start/end.
@@ -64,6 +65,7 @@ handle_t *__ext4_journal_start_sb(struct
 	}
 	return jbd2__journal_start(journal, nblocks, GFP_NOFS, type, line);
 }
+EXPORT_SYMBOL(__ext4_journal_start_sb);
 
 int __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle)
 {
@@ -85,6 +87,7 @@ int __ext4_journal_stop(const char *wher
 		__ext4_std_error(sb, where, line, err);
 	return err;
 }
+EXPORT_SYMBOL(__ext4_journal_stop);
 
 void ext4_journal_abort_handle(const char *caller, unsigned int line,
 			       const char *err_fn, struct buffer_head *bh,
@@ -263,3 +266,4 @@ int __ext4_handle_dirty_super(const char
 		mark_buffer_dirty(bh);
 	return err;
 }
+EXPORT_SYMBOL(__ext4_handle_dirty_metadata);
Index: linux-3.10.0-123.13.2.el7.x86_64/fs/ext4/inode.c
===================================================================
--- linux-3.10.0-123.13.2.el7.x86_64.orig/fs/ext4/inode.c
+++ linux-3.10.0-123.13.2.el7.x86_64/fs/ext4/inode.c
@@ -753,6 +753,7 @@ has_zeroout:
 	}
 	return retval;
 }
+EXPORT_SYMBOL(ext4_map_blocks);
 
 /* Maximum number of blocks we map for direct IO at once. */
 #define DIO_MAX_BLOCKS 4096
@@ -3906,6 +3907,7 @@ out_stop:
 
 	trace_ext4_truncate_exit(inode);
 }
+EXPORT_SYMBOL(ext4_truncate);
 
 /*
  * ext4_get_inode_loc returns with an extra refcount against the inode's
@@ -4363,6 +4365,7 @@ bad_inode:
 	iget_failed(inode);
 	return ERR_PTR(ret);
 }
+EXPORT_SYMBOL(ext4_iget);
 
 static int ext4_inode_blocks_set(handle_t *handle,
 				struct ext4_inode *raw_inode,
@@ -5188,6 +5191,7 @@ int ext4_change_inode_journal_flag(struc
 
 	return err;
 }
+EXPORT_SYMBOL(ext4_bread);
 
 static int ext4_bh_unmapped(handle_t *handle, struct buffer_head *bh)
 {
Index: linux-3.10.0-123.13.2.el7.x86_64/fs/ext4/super.c
===================================================================
--- linux-3.10.0-123.13.2.el7.x86_64.orig/fs/ext4/super.c
+++ linux-3.10.0-123.13.2.el7.x86_64/fs/ext4/super.c
@@ -1156,6 +1156,7 @@ enum {
 	Opt_stripe, Opt_delalloc, Opt_nodelalloc, Opt_mblk_io_submit,
 	Opt_nomblk_io_submit, Opt_block_validity, Opt_noblock_validity,
 	Opt_inode_readahead_blks, Opt_journal_ioprio,
+	Opt_mballoc,
 	Opt_dioread_nolock, Opt_dioread_lock,
 	Opt_discard, Opt_nodiscard, Opt_init_itable, Opt_noinit_itable,
 	Opt_max_dir_size_kb,
@@ -1209,6 +1210,7 @@ static const match_table_t tokens = {
 	{Opt_noquota, "noquota"},
 	{Opt_quota, "quota"},
 	{Opt_usrquota, "usrquota"},
+	{Opt_mballoc, "mballoc"},
 	{Opt_barrier, "barrier=%u"},
 	{Opt_barrier, "barrier"},
 	{Opt_nobarrier, "nobarrier"},
@@ -1468,6 +1470,8 @@ static int handle_mount_opt(struct super
 	case Opt_i_version:
 		sb->s_flags |= MS_I_VERSION;
 		return 1;
+	case Opt_mballoc:
+		return 1;
 	}
 
 	for (m = ext4_mount_opts; m->token != Opt_err; m++)
@@ -3288,6 +3292,7 @@ static int ext4_reserve_clusters(struct
 	atomic64_set(&sbi->s_resv_clusters, count);
 	return 0;
 }
+EXPORT_SYMBOL(ext4_itable_unused_count);
 
 static int ext4_fill_super(struct super_block *sb, void *data, int silent)
 {
@@ -4554,6 +4559,7 @@ int ext4_force_commit(struct super_block
 	journal = EXT4_SB(sb)->s_journal;
 	return ext4_journal_force_commit(journal);
 }
+EXPORT_SYMBOL(ext4_force_commit);
 
 static int ext4_sync_fs(struct super_block *sb, int wait)
 {
Index: linux-3.10.0-123.13.2.el7.x86_64/fs/ext4/namei.c
===================================================================
--- linux-3.10.0-123.13.2.el7.x86_64.orig/fs/ext4/namei.c
+++ linux-3.10.0-123.13.2.el7.x86_64/fs/ext4/namei.c
@@ -2210,7 +2210,7 @@ out:
  * DIR_NLINK feature is set if 1) nlinks > EXT4_LINK_MAX or 2) nlinks == 2,
  * since this indicates that nlinks count was previously 1.
  */
-static void ext4_inc_count(handle_t *handle, struct inode *inode)
+void ext4_inc_count(handle_t *handle, struct inode *inode)
 {
 	inc_nlink(inode);
 	if (is_dx(inode) && inode->i_nlink > 1) {
@@ -2222,16 +2222,18 @@ static void ext4_inc_count(handle_t *han
 		}
 	}
 }
+EXPORT_SYMBOL(ext4_inc_count);
 
 /*
  * If a directory had nlink == 1, then we should let it be 1. This indicates
  * directory has >EXT4_LINK_MAX subdirs.
  */
-static void ext4_dec_count(handle_t *handle, struct inode *inode)
+void ext4_dec_count(handle_t *handle, struct inode *inode)
 {
 	if (!S_ISDIR(inode->i_mode) || inode->i_nlink > 2)
 		drop_nlink(inode);
 }
+EXPORT_SYMBOL(ext4_dec_count);
 
 
 static int ext4_add_nondir(handle_t *handle,
Index: linux-3.10.0-123.13.2.el7.x86_64/fs/ext4/ialloc.c
===================================================================
--- linux-3.10.0-123.13.2.el7.x86_64.orig/fs/ext4/ialloc.c
+++ linux-3.10.0-123.13.2.el7.x86_64/fs/ext4/ialloc.c
@@ -111,7 +111,7 @@ void ext4_end_bitmap_read(struct buffer_
  *
  * Return buffer_head of bitmap on success or NULL.
  */
-static struct buffer_head *
+struct buffer_head *
 ext4_read_inode_bitmap(struct super_block *sb, ext4_group_t block_group)
 {
 	struct ext4_group_desc *desc;
@@ -191,6 +191,7 @@ verify:
 	set_buffer_verified(bh);
 	return bh;
 }
+EXPORT_SYMBOL(ext4_read_inode_bitmap);
 
 /*
  * NOTE! When we get the inode, we're the only people
Index: linux-3.10.0-123.13.2.el7.x86_64/fs/ext4/extents.c
===================================================================
--- linux-3.10.0-123.13.2.el7.x86_64.orig/fs/ext4/extents.c
+++ linux-3.10.0-123.13.2.el7.x86_64/fs/ext4/extents.c
@@ -4737,3 +4737,4 @@ int ext4_fiemap(struct inode *inode, str
 
 	return error;
 }
+EXPORT_SYMBOL(ext4_mark_inode_dirty);
Index: linux-3.10.0-123.13.2.el7.x86_64/fs/ext4/balloc.c
===================================================================
--- linux-3.10.0-123.13.2.el7.x86_64.orig/fs/ext4/balloc.c
+++ linux-3.10.0-123.13.2.el7.x86_64/fs/ext4/balloc.c
@@ -298,6 +298,7 @@ struct ext4_group_desc * ext4_get_group_
 		*bh = sbi->s_group_desc[group_desc];
 	return desc;
 }
+EXPORT_SYMBOL(ext4_get_group_desc);
 
 /*
  * Return the block number which was discovered to be invalid, or 0 if
