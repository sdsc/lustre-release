diff --git a/fs/ext4/namei.c b/fs/ext4/namei.c
index 5fa31c4..b74b9c9 100644
--- a/fs/ext4/namei.c
+++ b/fs/ext4/namei.c
@@ -36,6 +36,8 @@
 #include <linux/bio.h>
 #include "ext4.h"
 #include "ext4_jbd2.h"
+#include <linux/path.h>
+#include <linux/mount.h>
 
 #include "xattr.h"
 #include "acl.h"
@@ -2479,13 +2481,47 @@ int __ext4_add_entry(handle_t *handle, struct dentry *dentry,
 }
 EXPORT_SYMBOL(__ext4_add_entry);
 
+struct mount {
+	struct list_head mnt_hash;
+	struct mount *mnt_parent;
+	struct dentry *mnt_mountpoint;
+	struct vfsmount mnt;
+#ifdef CONFIG_SMP
+	struct mnt_pcp __percpu *mnt_pcp;
+#else
+	int mnt_count;
+	int mnt_writers;
+#endif
+	struct list_head mnt_mounts;	/* list of children, anchored here */
+	struct list_head mnt_child;	/* and going through their mnt_child */
+	struct list_head mnt_instance;	/* mount instance on sb->s_mounts */
+	const char *mnt_devname;	/* Name of device e.g. /dev/dsk/hda1 */
+	struct list_head mnt_list;
+	struct list_head mnt_expire;	/* link in fs-specific expiry list */
+	struct list_head mnt_share;	/* circular list of shared mounts */
+	struct list_head mnt_slave_list;/* list of slave mounts */
+	struct list_head mnt_slave;	/* slave list entry */
+	struct mount *mnt_master;	/* slave is on master->mnt_slave_list */
+	struct mnt_namespace *mnt_ns;	/* containing namespace */
+	struct mountpoint *mnt_mp;	/* where is it mounted */
+#ifdef CONFIG_FSNOTIFY
+	struct hlist_head mnt_fsnotify_marks;
+	__u32 mnt_fsnotify_mask;
+#endif
+	int mnt_id;			/* mount identifier */
+	int mnt_group_id;		/* peer group identifier */
+	int mnt_expiry_mark;		/* true if marked for expiry */
+	int mnt_pinned;
+	int mnt_ghosts;
+};
+
 /*
  * Returns 0 for success, or a negative error value
  */
 static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,
 			     struct inode *inode, struct htree_lock *lck)
 {
-	struct dx_frame frames[EXT4_HTREE_LEVEL], *frame;
+	struct dx_frame frames[EXT4_HTREE_LEVEL], *frame, *frame1;
 	struct dx_entry *entries, *at;
 	struct dx_hash_info hinfo;
 	struct buffer_head *bh;
@@ -2494,6 +2530,8 @@ static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,
 	struct ext4_dir_entry_2 *de;
 	int restart;
 	int err;
+	u64 max_dir_size = EXT4_BLOCK_SIZE(sb);
+	u64 size1, size2;
 
 again:
 	restart = 0;
@@ -2517,6 +2555,54 @@ again:
 	/* Block full, should compress but for now just split */
 	dxtrace(printk(KERN_DEBUG "using %u of %u node entries\n",
 		       dx_get_count(entries), dx_get_limit(entries)));
+
+	if (frame - frames + 1 < ext4_dir_htree_level(sb))
+		goto skip;
+	frame1 = frame;
+	if (EXT4_SB(dir->i_sb)->s_max_dir_size_kb)
+		max_dir_size = EXT4_SB(dir->i_sb)->s_max_dir_size_kb << 10;
+	else
+		while (frame1 >= frames) {
+			max_dir_size *= dx_get_limit(frame1->entries);
+			if (frame1 == frames)
+				break;
+			frame1--;
+		}
+	/* With hash tree growing, it is easy to hit ENOSPC,but
+	 * it is hard to predict when it will happen. let's give
+	 * administrators warning when reaching 50% and 75% of limit. */
+	max_dir_size = max_dir_size / 4 * 3;
+	size1 = max_dir_size / 2;
+	size2 = max_dir_size / 4 * 3;
+	if ((dir->i_size >= size1 &&
+	     dir->i_size - size1 < EXT4_BLOCK_SIZE(sb))
+	     || (dir->i_size >= size2 &&
+		dir->i_size - size2 < EXT4_BLOCK_SIZE(sb))) {
+		struct vfsmount vfsmount = { .mnt_root = sb->s_root,
+					     .mnt_sb = sb };
+		struct mount mount = { .mnt_parent = &mount,
+				       .mnt = vfsmount };
+		struct path path = { .mnt = &(mount.mnt),
+				     .dentry = dentry->d_parent };
+		char *p;
+		char *buf = kzalloc(PATH_MAX, GFP_NOFS);
+
+		if (!buf) {
+			err = -ENOMEM;
+			goto cleanup;
+		}
+		p = d_path(&path, buf, PATH_MAX);
+		if (IS_ERR(p))
+			p = "(unknown)";
+		else
+			p++; /* skip leading '/' */
+		ext4_warning(sb, "inode #%lu: comm %s: name %s: path %s: used %llu bytes: limit %llu bytes: now it will be easier to reach limit",
+				dir->i_ino, current->comm, dentry->d_parent->d_name.name, p,
+				(unsigned long long)dir->i_size, max_dir_size);
+		kfree(buf);
+	}
+
+skip:
 	/* Need to split index? */
 	if (dx_get_count(entries) == dx_get_limit(entries)) {
 		ext4_lblk_t newblock;
@@ -2544,9 +2630,28 @@ again:
 			restart = 1;
 		}
 		if (add_level && levels == ext4_dir_htree_level(sb)) {
-			ext4_warning(sb, "inode %lu: comm %s: index %u: reach max htree level %u",
-					 dir->i_ino, current->comm, levels,
-					 ext4_dir_htree_level(sb));
+			struct vfsmount vfsmount = { .mnt_root = sb->s_root,
+						     .mnt_sb = sb };
+			struct mount mount = { .mnt_parent = &mount,
+					       .mnt = vfsmount };
+			struct path path = { .mnt = &(mount.mnt),
+					     .dentry = dentry->d_parent };
+			char *p;
+			char *buf = kzalloc(PATH_MAX, GFP_NOFS);
+
+			if (!buf) {
+				err = -ENOMEM;
+				goto cleanup;
+			}
+			p = d_path(&path, buf, PATH_MAX);
+			if (IS_ERR(p))
+				p = "(unknown)";
+			else
+				p++; /* skip leading '/' */
+			ext4_warning(sb, "inode #%lu: comm %s: name %s: path %s: index full, reach max htree level %d:",
+					 dir->i_ino, current->comm,
+					 dentry->d_parent->d_name.name, p, levels);
+			kfree(buf);
 			if (ext4_dir_htree_level(sb) < EXT4_HTREE_LEVEL) {
 				ext4_warning(sb, "Large directory feature is"
 						 "not enabled on this "
-- 
1.8.3.1

