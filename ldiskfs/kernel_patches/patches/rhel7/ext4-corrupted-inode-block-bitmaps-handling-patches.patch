diff --git a/fs/ext4/balloc.c b/fs/ext4/balloc.c
index e069155..8ecf06e 100644
--- a/fs/ext4/balloc.c
+++ b/fs/ext4/balloc.c
@@ -377,7 +377,7 @@ static void ext4_validate_block_bitmap(struct super_block *sb,
 	blk = ext4_valid_block_bitmap(sb, desc, block_group, bh);
 	if (unlikely(blk != 0)) {
 		ext4_unlock_group(sb, block_group);
-		ext4_error(sb, "bg %u: block %llu: invalid block bitmap",
+		ext4_warning(sb, "bg %u: block %llu: invalid block bitmap",
 			   block_group, blk);
 		if (!EXT4_MB_GRP_BBITMAP_CORRUPT(grp))
 			percpu_counter_sub(&sbi->s_freeclusters_counter,
@@ -388,7 +388,7 @@ static void ext4_validate_block_bitmap(struct super_block *sb,
 	if (unlikely(!ext4_block_bitmap_csum_verify(sb, block_group,
 			desc, bh))) {
 		ext4_unlock_group(sb, block_group);
-		ext4_error(sb, "bg %u: bad block bitmap checksum", block_group);
+		ext4_warning(sb, "bg %u: bad block bitmap checksum", block_group);
 		if (!EXT4_MB_GRP_BBITMAP_CORRUPT(grp))
 			percpu_counter_sub(&sbi->s_freeclusters_counter,
 					   grp->bb_free);
@@ -446,7 +446,7 @@ ext4_read_block_bitmap_nowait(struct super_block *sb, ext4_group_t block_group)
 		ext4_unlock_group(sb, block_group);
 		unlock_buffer(bh);
 		if (err)
-			ext4_error(sb, "Checksum bad for grp %u", block_group);
+			ext4_warning(sb, "Checksum bad for grp %u", block_group);
 		return bh;
 	}
 	ext4_unlock_group(sb, block_group);
diff --git a/fs/ext4/ialloc.c b/fs/ext4/ialloc.c
index fc65310..4936bff 100644
--- a/fs/ext4/ialloc.c
+++ b/fs/ext4/ialloc.c
@@ -77,7 +77,7 @@ static unsigned ext4_init_inode_bitmap(struct super_block *sb,
 	/* If checksum is bad mark all blocks and inodes use to prevent
 	 * allocation, essentially implementing a per-group read-only flag. */
 	if (!ext4_group_desc_csum_verify(sb, block_group, gdp)) {
-		ext4_error(sb, "Checksum bad for group %u", block_group);
+		ext4_warning(sb, "Checksum bad for group %u", block_group);
 		grp = ext4_get_group_info(sb, block_group);
 		if (!EXT4_MB_GRP_BBITMAP_CORRUPT(grp))
 			percpu_counter_sub(&sbi->s_freeclusters_counter,
@@ -193,8 +193,8 @@ verify:
 					   EXT4_INODES_PER_GROUP(sb) / 8)) {
 		ext4_unlock_group(sb, block_group);
 		put_bh(bh);
-		ext4_error(sb, "Corrupt inode bitmap - block_group = %u, "
-			   "inode_bitmap = %llu", block_group, bitmap_blk);
+		ext4_warning(sb, "Corrupt inode bitmap - block_group = %u, "
+				 "inode_bitmap = %llu", block_group, bitmap_blk);
 		grp = ext4_get_group_info(sb, block_group);
 		if (!EXT4_MB_GRP_IBITMAP_CORRUPT(grp)) {
 			int count;
@@ -337,7 +337,7 @@ out:
 		if (!fatal)
 			fatal = err;
 	} else {
-		ext4_error(sb, "bit already cleared for inode %lu", ino);
+		ext4_warning(sb, "bit already cleared for inode %lu", ino);
 		if (gdp && !EXT4_MB_GRP_IBITMAP_CORRUPT(grp)) {
 			int count;
 			count = ext4_free_inodes_count(sb, gdp);
diff --git a/fs/ext4/mballoc.c b/fs/ext4/mballoc.c
index d2b07bd..f2ae94c 100644
--- a/fs/ext4/mballoc.c
+++ b/fs/ext4/mballoc.c
@@ -752,11 +752,18 @@ int ext4_mb_generate_buddy(struct super_block *sb,
 	if (free != grp->bb_free) {
 		struct ext4_group_desc *gdp;
 		gdp = ext4_get_group_desc(sb, group, NULL);
-		ext4_error(sb, "group %lu: %u blocks in bitmap, %u in bb, "
-			"%u in gd, %lu pa's\n", (long unsigned int)group,
+		ext4_warning(sb, "group %lu: %u blocks in bitmap, %u in bb, "
+			"%u in gd, %lu pa's block bitmap corrupt",
+			(long unsigned int)group,
 			free, grp->bb_free, ext4_free_group_clusters(sb, gdp),
 			grp->bb_prealloc_nr);
-		return -EIO;
+		/*
+		 * If we intend to continue, we consider group descriptor
+		 * corrupt and update bb_free using bitmap value
+		 */
+		grp->bb_free = free;
+		set_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &grp->bb_state);
+		
 	}
 	mb_set_largest_free_order(sb, grp);
 
@@ -3585,6 +3592,7 @@ int ext4_mb_check_ondisk_bitmap(struct super_block *sb, void *bitmap,
 {
 	unsigned short max = EXT4_BLOCKS_PER_GROUP(sb);
 	unsigned short i, first, free = 0;
+	struct ext4_group_info *grp = ext4_get_group_info(sb, group);
 
 	i = mb_find_next_zero_bit(bitmap, max, 0);
 
@@ -3599,9 +3607,10 @@ int ext4_mb_check_ondisk_bitmap(struct super_block *sb, void *bitmap,
 	}
 
 	if (free != ext4_free_group_clusters(sb, gdp)) {
-		ext4_error(sb, "on-disk bitmap for group %d"
+		ext4_warning(sb, "on-disk bitmap for group %d"
 			"corrupted: %u blocks free in bitmap, %u - in gd\n",
 			group, free, ext4_free_group_clusters(sb, gdp));
+		set_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &grp->bb_state);
 		return -EIO;
 	}
 	return 0;
@@ -3962,7 +3971,7 @@ ext4_mb_release_inode_pa(struct ext4_buddy *e4b, struct buffer_head *bitmap_bh,
 	/* "free < pa->pa_free" means we maybe double alloc the same blocks,
 	 * otherwise maybe leave some free blocks unavailable, no need to BUG.*/
 	if ((free > pa->pa_free && !pa->pa_error) || (free < pa->pa_free)) {
-		ext4_error(sb, "pa free mismatch: [pa %p] "
+		ext4_warning(sb, "pa free mismatch: [pa %p] "
 				"[phy %lu] [logic %lu] [len %u] [free %u] "
 				"[error %u] [inode %lu] [freed %u]", pa,
 				(unsigned long)pa->pa_pstart,
@@ -4031,14 +4040,12 @@ ext4_mb_discard_group_preallocations(struct super_block *sb,
 		return 0;
 
 	bitmap_bh = ext4_read_block_bitmap(sb, group);
-	if (bitmap_bh == NULL) {
-		ext4_error(sb, "Error reading block bitmap for %u", group);
+	if (bitmap_bh == NULL)
 		return 0;
-	}
 
 	err = ext4_mb_load_buddy(sb, group, &e4b);
 	if (err) {
-		ext4_error(sb, "Error loading buddy information for %u", group);
+		ext4_warning(sb, "Error loading buddy information for %u", group);
 		put_bh(bitmap_bh);
 		return 0;
 	}
@@ -4199,15 +4206,13 @@ repeat:
 
 		err = ext4_mb_load_buddy(sb, group, &e4b);
 		if (err) {
-			ext4_error(sb, "Error loading buddy information for %u",
+			ext4_warning(sb, "Error loading buddy information for %u",
 					group);
 			return;
 		}
 
 		bitmap_bh = ext4_read_block_bitmap(sb, group);
 		if (bitmap_bh == NULL) {
-			ext4_error(sb, "Error reading block bitmap for %u",
-					group);
 			ext4_mb_unload_buddy(&e4b);
 			continue;
 		}
@@ -4468,7 +4473,7 @@ ext4_mb_discard_lg_preallocations(struct super_block *sb,
 
 		group = ext4_get_group_number(sb, pa->pa_pstart);
 		if (ext4_mb_load_buddy(sb, group, &e4b)) {
-			ext4_error(sb, "Error loading buddy information for %u",
+			ext4_warning(sb, "Error loading buddy information for %u",
 					group);
 			continue;
 		}
@@ -4742,7 +4747,7 @@ errout:
 			 * been updated or not when fail case. So can
 			 * not revert pa_free back, just mark pa_error*/
 			pa->pa_error++;
-			ext4_error(sb,
+			ext4_warning(sb,
 				"Updating bitmap error: [err %d] "
 				"[pa %p] [phy %lu] [logic %lu] "
 				"[len %u] [free %u] [error %u] "
@@ -5330,7 +5335,7 @@ ext4_trim_all_free(struct super_block *sb, ext4_group_t group,
 
 	ret = ext4_mb_load_buddy(sb, group, &e4b);
 	if (ret) {
-		ext4_error(sb, "Error in loading buddy "
+		ext4_warning(sb, "Error in loading buddy "
 				"information for %u", group);
 		return ret;
 	}
