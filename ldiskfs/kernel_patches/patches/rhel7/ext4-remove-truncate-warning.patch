There will cause a deadlock if invoke ext4_truncate with i_mutex locked
in lustre. Since lustre has own lock to provide protect so we don't
need this check at all. 

Index: linux-3.10.0-229.1.2.fc21.x86_64/fs/ext4/inode.c
===================================================================
--- linux-3.10.0-229.1.2.fc21.x86_64.orig/fs/ext4/inode.c
+++ linux-3.10.0-229.1.2.fc21.x86_64/fs/ext4/inode.c
@@ -3644,8 +3644,6 @@ void ext4_truncate(struct inode *inode)
 	 * or it completely new indode. In those cases we might not
 	 * have i_mutex locked because it's not necessary.
 	 */
-	if (!(inode->i_state & (I_NEW|I_FREEING)))
-		WARN_ON(!mutex_is_locked(&inode->i_mutex));
 	trace_ext4_truncate_enter(inode);
 
 	if (!ext4_can_truncate(inode))
Index: linux-3.10.0-229.1.2.fc21.x86_64/fs/ext4/namei.c
===================================================================
--- linux-3.10.0-229.1.2.fc21.x86_64.orig/fs/ext4/namei.c
+++ linux-3.10.0-229.1.2.fc21.x86_64/fs/ext4/namei.c
@@ -1244,6 +1244,7 @@ static int ext4_htree_next_block(struct
  * directory block.  It returns the number directory entries loaded
  * into the tree.  If there is an error it is returned in err.
  */
+#include <linux/sysrq.h>
 static int htree_dirblock_to_tree(struct file *dir_file,
 				  struct inode *dir, ext4_lblk_t block,
 				  struct dx_hash_info *hinfo,
@@ -1269,6 +1270,8 @@ static int htree_dirblock_to_tree(struct
 				(block<<EXT4_BLOCK_SIZE_BITS(dir->i_sb))
 					 + ((char *)de - bh->b_data))) {
 			/* silently ignore the rest of the block */
+printk(KERN_EMERG"dir-name=%s\n", dir_file->f_path.dentry->d_name.name);
+			handle_sysrq('t');
 			break;
 		}
 		ext4fs_dirhash(de->name, de->name_len, hinfo);
@@ -3163,8 +3163,6 @@ int ext4_orphan_add(handle_t *handle, st
 	if (!sbi->s_journal || is_bad_inode(inode))
 		return 0;
 
-	WARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&
-		     !mutex_is_locked(&inode->i_mutex));
 	/*
 	 * Exit early if inode already is on orphan list. This is a big speedup
 	 * since we don't have to contend on the global s_orphan_lock.
@@ -3245,8 +3243,6 @@ int ext4_orphan_del(handle_t *handle, st
 	if (!sbi->s_journal && !(sbi->s_mount_state & EXT4_ORPHAN_FS))
 		return 0;
 
-	WARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&
-		     !mutex_is_locked(&inode->i_mutex));
 	/* Do this quick check before taking global s_orphan_lock. */
 	if (list_empty(&ei->i_orphan))
 		return 0;
