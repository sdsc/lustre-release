Index: linux-stage/fs/ext4/super.c
===================================================================
--- linux-stage.orig/fs/ext4/super.c
+++ linux-stage/fs/ext4/super.c
@@ -660,9 +660,22 @@ static void ext4_put_super(struct super_
 	}
 	kobject_del(&sbi->s_kobj);
 
-	for (i = 0; i < sbi->s_gdb_count; i++)
+	for (i = 0; i < sbi->s_gdb_count; i++) {
+		printk(KERN_INFO "release sbi->s_group_desc[%u]\n", i);
 		brelse(sbi->s_group_desc[i]);
-	kfree(sbi->s_group_desc);
+	}
+
+	if (sbi->s_group_desc) {
+		printk(KERN_INFO "free the memory for sbi->s_group_desc\n");
+		if (is_vmalloc_addr(sbi->s_group_desc)) {
+			printk(KERN_INFO "free the memory by using vfree()\n");
+			vfree(sbi->s_group_desc);
+		} else {
+			printk(KERN_INFO "free the memory by using kfree()\n");
+			kfree(sbi->s_group_desc);
+		}
+	}
+
 	if (is_vmalloc_addr(sbi->s_flex_groups))
 		vfree(sbi->s_flex_groups);
 	else
@@ -2408,6 +2421,7 @@ static int ext4_fill_super(struct super_
 	int ret = -EINVAL;
 	int blocksize;
 	unsigned int db_count;
+	size_t size;
 	unsigned int i;
 	int needs_recovery, has_huge_files;
 	__u64 blocks_count;
@@ -2716,12 +2730,28 @@ static int ext4_fill_super(struct super_
 	sbi->s_groups_count = blocks_count;
 	sbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,
 			(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));
+	printk(KERN_INFO "sbi->s_groups_count is %u\n", sbi->s_groups_count);
 	db_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /
 		   EXT4_DESC_PER_BLOCK(sb);
-	sbi->s_group_desc = kmalloc(db_count * sizeof(struct buffer_head *),
-				    GFP_KERNEL);
+	size = (size_t) db_count * sizeof(struct buffer_head *);
+	printk(KERN_INFO "db_count is %u\n", db_count);
+	printk(KERN_INFO "buffer_head size is %u\n", (unsigned int) sizeof(struct buffer_head *));
+	sbi->s_group_desc = kzalloc(size, GFP_KERNEL);
+	if (sbi->s_group_desc == NULL) {
+		ext4_msg(sb, KERN_INFO, "not enough memory for %u groups (%u), "
+			"falling back to vmalloc()",
+			sbi->s_groups_count, (unsigned int) size);
+		sbi->s_group_desc = vmalloc(size);
+		if (sbi->s_group_desc) {
+			memset(sbi->s_group_desc, 0, size);
+			ext4_msg(sb, KERN_INFO, "allocted enough memory for %u groups (%u) "
+				"by running vmalloc()",
+				sbi->s_groups_count, (unsigned int) size);
+		}
+	}
 	if (sbi->s_group_desc == NULL) {
-		ext4_msg(sb, KERN_ERR, "not enough memory");
+		ext4_msg(sb, KERN_ERR, "not enough memory for %u groups (%u)\n",
+			sbi->s_groups_count, (unsigned int) size);
 		goto failed_mount;
 	}
 
@@ -2733,8 +2763,24 @@ static int ext4_fill_super(struct super_
 	bgl_lock_init(sbi->s_blockgroup_lock);
 
 	for (i = 0; i < db_count; i++) {
+		printk(KERN_INFO "VMALLOC_START[%u], %p\n", i, VMALLOC_START);
+		printk(KERN_INFO "VMALLOC_END[%u], %p\n", i, VMALLOC_END);
+		printk(KERN_INFO "address of sbi->s_group_desc[%u], %p\n", i, &sbi->s_group_desc[i]);
+	}
+
+	for (i = 0; i < db_count; i++) {
+		printk(KERN_INFO "logical_sb_block[%u] is %llu\n", i, logical_sb_block);
+		block = descriptor_loc(sb, logical_sb_block, i);
+		printk(KERN_INFO "block[%u] is %llu\n", i, block);
+	}
+
+	for (i = 0; i < db_count; i++) {
+		printk(KERN_INFO "logical_sb_block[%u] is %llu\n", i, logical_sb_block);
 		block = descriptor_loc(sb, logical_sb_block, i);
+		printk(KERN_INFO "block[%u] is %llu\n", i, block);
+		printk(KERN_INFO "address of sbi->s_group_desc[%u], %p\n", i, &sbi->s_group_desc[i]);
 		sbi->s_group_desc[i] = sb_bread(sb, block);
+		printk(KERN_INFO "init sbi->s_group_desc[%u]\n", i);
 		if (!sbi->s_group_desc[i]) {
 			ext4_msg(sb, KERN_ERR,
 			       "can't read group descriptor %d", i);
@@ -2742,6 +2788,9 @@ static int ext4_fill_super(struct super_
 			goto failed_mount2;
 		}
 	}
+	printk(KERN_INFO "init sbi->s_group_desc[%u] succeed\n", i);
+
+	printk(KERN_INFO "ext4_check_descriptors\n");
 	if (!ext4_check_descriptors(sb)) {
 		ext4_msg(sb, KERN_ERR, "group descriptors corrupted!");
 		goto failed_mount2;
@@ -2766,6 +2815,7 @@ static int ext4_fill_super(struct super_
 				ext4_count_dirs(sb));
 	percpu_counter_init(&sbi->s_dirtyblocks_counter, 0);
 
+	printk(KERN_INFO "ext4_get_stripe_size\n");
 	sbi->s_stripe = ext4_get_stripe_size(sbi);
 
 	/*
@@ -2903,6 +2953,7 @@ no_journal:
 	 * so we can safely mount the rest of the filesystem now.
 	 */
 
+	printk(KERN_INFO "ext4_iget\n");
 	root = ext4_iget(sb, EXT4_ROOT_INO);
 	if (IS_ERR(root)) {
 		ext4_msg(sb, KERN_ERR, "get root inode failed");
@@ -2922,6 +2973,7 @@ no_journal:
 		goto failed_mount4;
 	}
 
+	printk(KERN_INFO "ext4_setup_super\n");
 	ext4_setup_super(sb, es, sb->s_flags & MS_RDONLY);
 
 	/* determine the minimum size of new large inodes, if present */
@@ -2956,6 +3008,7 @@ no_journal:
 		clear_opt(sbi->s_mount_opt, DELALLOC);
 	}
 
+	printk(KERN_INFO "ext4_setup_system_zone\n");
 	err = ext4_setup_system_zone(sb);
 	if (err) {
 		ext4_msg(sb, KERN_ERR, "failed to initialize system "
@@ -2963,7 +3016,9 @@ no_journal:
 		goto failed_mount4;
 	}
 
+	printk(KERN_INFO "ext4_ext_init\n");
 	ext4_ext_init(sb);
+	printk(KERN_INFO "ext4_mb_init\n");
 	err = ext4_mb_init(sb, needs_recovery);
 	if (err) {
 		ext4_msg(sb, KERN_ERR, "failed to initalize mballoc (%d)",
@@ -2974,6 +3029,7 @@ no_journal:
 	sbi->s_kobj.kset = &ext4_kset;
 	sbi->s_kobj.ktype = &ext4_ktype;
 	init_completion(&sbi->s_kobj_unregister);
+	printk(KERN_INFO "kobject_set_name\n");
 	err = kobject_set_name(&sbi->s_kobj, "%s", sb->s_id);
 	if (!err)
 		err = kobject_register(&sbi->s_kobj);
@@ -2984,6 +3040,7 @@ no_journal:
 	};
 
 	EXT4_SB(sb)->s_mount_state |= EXT4_ORPHAN_FS;
+	printk(KERN_INFO "ext4_orphan_cleanup\n");
 	ext4_orphan_cleanup(sb, es);
 	EXT4_SB(sb)->s_mount_state &= ~EXT4_ORPHAN_FS;
 	if (needs_recovery) {
@@ -3031,9 +3088,21 @@ failed_mount3:
 	percpu_counter_destroy(&sbi->s_dirs_counter);
 	percpu_counter_destroy(&sbi->s_dirtyblocks_counter);
 failed_mount2:
-	for (i = 0; i < db_count; i++)
+	for (i = 0; i < db_count; i++) {
+		printk(KERN_INFO "release sbi->s_group_desc[%u]\n", i);
 		brelse(sbi->s_group_desc[i]);
-	kfree(sbi->s_group_desc);
+	}
+
+	if (sbi->s_group_desc) {
+		printk(KERN_INFO "free the memory for sbi->s_group_desc\n");
+		if (is_vmalloc_addr(sbi->s_group_desc)) {
+			printk(KERN_INFO "free the memory by using vfree()\n");
+			vfree(sbi->s_group_desc);
+		} else {
+			printk(KERN_INFO "free the memory by using kfree()\n");
+			kfree(sbi->s_group_desc);
+		}
+	}
 failed_mount:
 	if (sbi->s_proc) {
 		remove_proc_entry(sb->s_id, ext4_proc_root);
