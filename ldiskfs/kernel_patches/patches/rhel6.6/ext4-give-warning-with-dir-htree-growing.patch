diff --git a/fs/ext4/namei.c b/fs/ext4/namei.c
index b14034b..4e3f70e 100644
--- a/fs/ext4/namei.c
+++ b/fs/ext4/namei.c
@@ -35,6 +35,7 @@
 #include <linux/quotaops.h>
 #include <linux/buffer_head.h>
 #include <linux/bio.h>
+#include <linux/mount.h>
 #include "ext4.h"
 #include "ext4_jbd2.h"
 
@@ -2059,7 +2060,7 @@ EXPORT_SYMBOL(__ext4_add_entry);
 static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,
 			     struct inode *inode, struct htree_lock *lck)
 {
-	struct dx_frame frames[EXT4_HTREE_LEVEL], *frame;
+	struct dx_frame frames[EXT4_HTREE_LEVEL], *frame, *frame1;
 	struct dx_entry *entries, *at;
 	struct dx_hash_info hinfo;
 	struct buffer_head *bh;
@@ -2068,6 +2069,8 @@ static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,
 	struct ext4_dir_entry_2 *de;
 	int restart;
 	int err;
+	u64 max_dir_size = EXT4_BLOCK_SIZE(sb);
+	u64 size1, size2;
 
 again:
 	restart = 0;
@@ -2088,6 +2091,51 @@ again:
 	/* Block full, should compress but for now just split */
 	dxtrace(printk(KERN_DEBUG "using %u of %u node entries\n",
 		       dx_get_count(entries), dx_get_limit(entries)));
+
+	if (frame - frames + 1 < ext4_dir_htree_level(sb))
+		goto skip;
+	frame1 = frame;
+	if (EXT4_SB(dir->i_sb)->s_max_dir_size)
+		max_dir_size = EXT4_SB(dir->i_sb)->s_max_dir_size;
+	else
+		while (frame1 >= frames) {
+			max_dir_size *= dx_get_limit(frame1->entries);
+			if (frame1 == frames)
+				break;
+			frame1--;
+		}
+	/* With hash tree growing, it is easy to hit ENOSPC,but
+	 * it is hard to predict when it will happen. let's give
+	 * administrators warning when reaching 50% and 75% of limit. */
+	max_dir_size = max_dir_size / 4 * 3;
+	size1 = max_dir_size / 2;
+	size2 = max_dir_size / 4 * 3;
+	if ((dir->i_size >= size1 &&
+	     dir->i_size - size1 < EXT4_BLOCK_SIZE(sb))
+	    || (dir->i_size >= size2 &&
+		dir->i_size - size2 < EXT4_BLOCK_SIZE(sb))) {
+		struct vfsmount vfsmount = { .mnt_root = sb->s_root, .mnt_sb = sb,
+					     .mnt_parent = &vfsmount };
+		struct path path = { .mnt = &vfsmount, .dentry = dentry->d_parent };
+		char *p;
+		char *buf = kzalloc(PATH_MAX, GFP_NOFS);
+
+		if (!buf) {
+			err = -ENOMEM;
+			goto cleanup;
+		}
+		p = d_path(&path, buf, PATH_MAX);
+		if (IS_ERR(p))
+			p = "(unknown)";
+		else
+			p++; /* skip leading '/' */
+		ext4_warning(sb, "inode #%lu: comm %s: name %s: path %s: used %llu bytes: limit %llu bytes: now it will be easier to reach limit",
+				dir->i_ino, current->comm, dentry->d_parent->d_name.name, p,
+				(unsigned long long)dir->i_size, max_dir_size);
+		kfree(buf);
+	}
+
+skip:
 	/* Need to split index? */
 	if (dx_get_count(entries) == dx_get_limit(entries)) {
 		ext4_lblk_t newblock;
@@ -2115,11 +2163,28 @@ again:
 			restart = 1;
 		}
 		if (add_level && levels == ext4_dir_htree_level(sb)) {
-			ext4_warning(sb, "Directory (ino: %lu) index full, "
-					 "reach max htree level :%d",
-					 dir->i_ino, levels);
+			struct vfsmount vfsmount = { .mnt_root = sb->s_root, .mnt_sb = sb,
+						     .mnt_parent = &vfsmount };
+			struct path path = { .mnt = &vfsmount, .dentry = dentry->d_parent };
+			char *p;
+			char *buf = kzalloc(PATH_MAX, GFP_NOFS);
+
+			if (!buf) {
+				err = -ENOMEM;
+				goto cleanup;
+			}
+			p = d_path(&path, buf, PATH_MAX);
+			if (IS_ERR(p))
+				p = "(unknown)";
+			else
+				p++; /* skip leading '/' */
+			ext4_warning(sb, "inode #%lu: comm %s: name %s: path %s: index full, reach max htree level %d:",
+					 dir->i_ino, current->comm,
+					 dentry->d_parent->d_name.name, p, levels);
+			kfree(buf);
+
 			if (ext4_dir_htree_level(sb) < EXT4_HTREE_LEVEL) {
-				ext4_warning(sb, "Large directory feature is"
+				ext4_warning(sb, "Large directory feature is "
 						 "not enabled on this "
 						 "filesystem");
 			}
-- 
1.8.3.1

