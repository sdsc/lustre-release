diff --git a/fs/ext4/namei.c b/fs/ext4/namei.c
index e0b4fab..e1b71fa 100644
--- a/fs/ext4/namei.c
+++ b/fs/ext4/namei.c
@@ -37,6 +37,7 @@
 #include <linux/bio.h>
 #include "ext4.h"
 #include "ext4_jbd2.h"
+#include <linux/mount.h>
 
 #include "xattr.h"
 #include "acl.h"
@@ -2048,7 +2049,7 @@ EXPORT_SYMBOL(ext4_add_entry);
 static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,
 			     struct inode *inode, struct htree_lock *lck)
 {
-	struct dx_frame frames[EXT4_HTREE_LEVEL], *frame;
+	struct dx_frame frames[EXT4_HTREE_LEVEL], *frame, *frame1;
 	struct dx_entry *entries, *at;
 	struct dx_hash_info hinfo;
 	struct buffer_head *bh;
@@ -2057,6 +2058,8 @@ static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,
 	struct ext4_dir_entry_2 *de;
 	int restart;
 	int err;
+	u64 size;
+	u64 max_dir_size = EXT4_BLOCK_SIZE(sb);
 
 again:
 	restart = 0;
@@ -2077,6 +2080,49 @@ again:
 	/* Block full, should compress but for now just split */
 	dxtrace(printk(KERN_DEBUG "using %u of %u node entries\n",
 		       dx_get_count(entries), dx_get_limit(entries)));
+
+	if (frame - frames + 1 < ext4_dir_htree_level(sb))
+		goto skip;
+	frame1 = frame;
+	if (EXT4_SB(dir->i_sb)->s_max_dir_size)
+		max_dir_size = EXT4_SB(dir->i_sb)->s_max_dir_size;
+	else
+		while (frame1 >= frames) {
+			max_dir_size *= dx_get_limit(frame1->entries);
+			if (frame1 == frames)
+				break;
+			frame1--; 
+		}
+	/*
+ 	 * With hash tree growing, it is easy to hit ENOSPC,
+ 	 * but it is hard to predict when it will happen.
+ 	 * let's give admin warning when reaching half of limit
+ 	 * and 75% of limit.
+ 	 */
+	size = max_dir_size / 2;
+	if (dir->i_size >= size &&
+	    !((dir->i_size - size) % (max_dir_size / 4)) &&
+	    dir->i_size < max_dir_size) {
+		struct vfsmount vfsmount = { .mnt_root = sb->s_root, .mnt_sb = sb, .mnt_parent = &vfsmount};
+		struct path path = { .mnt = &vfsmount, .dentry = dentry->d_parent};
+		char *p;
+		char *buf = kzalloc(PAGE_SIZE, GFP_NOFS);
+		if (!buf) {
+			err = -ENOMEM;
+			goto cleanup;
+		}
+		p = d_path(&path, buf, PAGE_SIZE);
+		if (IS_ERR(p))
+			p = "(unknown)";
+		else
+			p++; /* skip leading '/' */
+		ext4_warning(sb, "Directory (ino: %lu, name: %s path: %s) used: %llu, limit: %llu, now it will be easier to reach limit",
+				dir->i_ino, dentry->d_parent->d_name.name, p,
+				(unsigned long long)dir->i_size, max_dir_size);
+		kfree(buf);
+	}
+
+skip:
 	/* Need to split index? */
 	if (dx_get_count(entries) == dx_get_limit(entries)) {
 		ext4_lblk_t newblock;
@@ -2104,11 +2150,25 @@ again:
 			restart = 1;
 		}
 		if (add_level && levels == ext4_dir_htree_level(sb)) {
-			ext4_warning(sb, "Directory (ino: %lu) index full, "
-					 "reach max htree level :%d",
-					 dir->i_ino, levels);
+			struct vfsmount vfsmount = { .mnt_root = sb->s_root, .mnt_sb = sb, .mnt_parent = &vfsmount};
+			struct path path = { .mnt = &vfsmount, .dentry = dentry->d_parent};
+			char *p;
+			char *buf = kzalloc(PAGE_SIZE, GFP_NOFS);
+			if (!buf) {
+				err = -ENOMEM;
+				goto cleanup;
+			}
+			p = d_path(&path, buf, PAGE_SIZE);
+			if (IS_ERR(p))
+				p = "(unknown)";
+			else
+				p++; /* skip leading '/' */
+			ext4_warning(sb, "Directory (ino: %lu, name: %s path: %s) index full, reach max htree level: %d",
+					 dir->i_ino, dentry->d_parent->d_name.name, p, levels);
+			kfree(buf);
+
 			if (ext4_dir_htree_level(sb) < EXT4_HTREE_LEVEL) {
-				ext4_warning(sb, "Large directory feature is"
+				ext4_warning(sb, "Large directory feature is "
 						 "not enabled on this "
 						 "filesystem");
 			}
-- 
1.7.1

