---
 fs/ext4/ext4.h         |    6 +++++
 fs/ext4/ext4_extents.h |   10 +++++++++
 fs/ext4/ext4_jbd2.h    |    3 ++
 fs/ext4/extents.c      |   50 +++++++++++++++++++++++++++++++++++++++++++++++++
 fs/ext4/super.c        |   12 +++++++++++
 5 files changed, 81 insertions(+)

--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -1308,6 +1308,9 @@ static inline void ext4_clear_state_flag

 #define NEXT_ORPHAN(inode) EXT4_I(inode)->i_dtime

+/* Has been moved to linux/magic.h but we need it for Lustre */
+#define EXT4_SUPER_MAGIC	0xEF53
+
 /*
  * Codes for operating systems
  */
@@ -1783,6 +1783,8 @@ extern struct inode * ext4_orphan_get(st
 extern unsigned long ext4_count_free_inodes(struct super_block *);
 extern unsigned long ext4_count_dirs(struct super_block *);
 extern void ext4_check_inodes_bitmap(struct super_block *);
+extern struct buffer_head *ext4_read_inode_bitmap(struct super_block *sb,
+						  ext4_group_t block_group);
 extern void ext4_mark_bitmap_end(int start_bit, int end_bit, char *bitmap);
 extern int ext4_init_inode_table(struct super_block *sb,
 				 ext4_group_t group, int barrier);
--- a/fs/ext4/ext4_jbd2.c
+++ b/fs/ext4/ext4_jbd2.c
@@ -19,6 +19,7 @@ int __ext4_journal_get_write_access(cons
 	}
 	return err;
 }
+EXPORT_SYMBOL(__ext4_journal_get_write_access);

 /*
  * The ext4 forget function must perform a revoke if we are freeing data
@@ -150,3 +151,4 @@ int __ext4_handle_dirty_super(const char
 		sb->s_dirt = 1;
 	return err;
 }
+EXPORT_SYMBOL(__ext4_handle_dirty_metadata);
--- a/fs/ext4/ext4_jbd2.h
+++ b/fs/ext4/ext4_jbd2.h
@@ -35,6 +35,8 @@
 	(EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_EXTENTS)   \
 	 ? 27U : 8U)

+#define ext4_journal_dirty_metadata(handle, bh)  \
+		ext4_handle_dirty_metadata(handle, NULL, bh)
 /* Extended attribute operations touch at most two data buffers,
  * two bitmap buffers, and two group summaries, in addition to the inode
  * and the superblock, which are already accounted for. */
@@ -175,6 +177,7 @@ static inline void ext4_journal_callback
 	list_del_init(&jce->jce_list);
 	spin_unlock(&sbi->s_md_lock);
 }
+#define HAVE_EXT4_JOURNAL_CALLBACK_ADD

 int
 ext4_mark_iloc_dirty(handle_t *handle,
Index: linux-stage/fs/ext4/extents.c
===================================================================
--- linux-stage.orig/fs/ext4/extents.c
+++ linux-stage/fs/ext4/extents.c
@@ -4488,3 +4537,5 @@ int ext4_fiemap(struct inode *inode, str
 
 	return error;
 }
+
+EXPORT_SYMBOL(ext4_mark_inode_dirty);
Index: linux-stage/fs/ext4/inode.c
===================================================================
--- linux-stage.orig/fs/ext4/inode.c
+++ linux-stage/fs/ext4/inode.c
@@ -5549,6 +5549,8 @@ bad_inode:
 	iget_failed(inode);
 	return ERR_PTR(ret);
 }
+EXPORT_SYMBOL(ext4_iget);
+EXPORT_SYMBOL(ext4_get_block);
 
 static int ext4_inode_blocks_set(handle_t *handle,
 				struct ext4_inode *raw_inode,
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -1332,12 +1332,14 @@ enum {
 	Opt_data_err_abort, Opt_data_err_ignore,
 	Opt_usrjquota, Opt_grpjquota, Opt_offusrjquota, Opt_offgrpjquota,
 	Opt_jqfmt_vfsold, Opt_jqfmt_vfsv0, Opt_jqfmt_vfsv1, Opt_quota,
+	Opt_iopen, Opt_noiopen, Opt_iopen_nopriv,
 	Opt_noquota, Opt_ignore, Opt_barrier, Opt_nobarrier, Opt_err,
 	Opt_resize, Opt_usrquota, Opt_grpquota, Opt_i_version,
 	Opt_stripe, Opt_delalloc, Opt_nodelalloc, Opt_mblk_io_submit,
 	Opt_nomblk_io_submit, Opt_block_validity, Opt_noblock_validity,
 	Opt_inode_readahead_blks, Opt_journal_ioprio,
 	Opt_dioread_nolock, Opt_dioread_lock,
+	Opt_mballoc,
 	Opt_discard, Opt_nodiscard, Opt_init_itable, Opt_noinit_itable,
 };

@@ -1390,6 +1392,9 @@ static const match_table_t tokens = {
 	{Opt_noquota, "noquota"},
 	{Opt_quota, "quota"},
 	{Opt_usrquota, "usrquota"},
+	{Opt_iopen, "iopen"},
+	{Opt_noiopen, "noiopen"},
+	{Opt_iopen_nopriv, "iopen_nopriv"},
 	{Opt_barrier, "barrier=%u"},
 	{Opt_barrier, "barrier"},
 	{Opt_nobarrier, "nobarrier"},
@@ -1409,6 +1414,7 @@ static const match_table_t tokens = {
 	{Opt_noauto_da_alloc, "noauto_da_alloc"},
 	{Opt_dioread_nolock, "dioread_nolock"},
 	{Opt_dioread_lock, "dioread_lock"},
+	{Opt_mballoc, "mballoc"},
 	{Opt_discard, "discard"},
 	{Opt_nodiscard, "nodiscard"},
 	{Opt_init_itable, "init_itable=%u"},
@@ -1793,6 +1799,10 @@ set_qf_format:
 			else
 				clear_opt(sb, BARRIER);
 			break;
+		case Opt_iopen:
+		case Opt_noiopen:
+		case Opt_iopen_nopriv:
+			break;
 		case Opt_ignore:
 			break;
 		case Opt_resize:
@@ -1904,6 +1914,8 @@ set_qf_format:
 		case Opt_noinit_itable:
 			clear_opt(sb, INIT_INODE_TABLE);
 			break;
+		case Opt_mballoc:
+			break;
 		default:
 			ext4_msg(sb, KERN_ERR,
 			       "Unrecognized mount option \"%s\" "
@@ -5208,6 +5211,11 @@ static void __exit ext4_exit_fs(void)
 	ext4_exit_pageio();
 }

+EXPORT_SYMBOL(ext4_bread);
+EXPORT_SYMBOL(ext4_journal_start_sb);
+EXPORT_SYMBOL(__ext4_journal_stop);
+EXPORT_SYMBOL(ext4_force_commit);
+
 MODULE_AUTHOR("Remy Card, Stephen Tweedie, Andrew Morton, Andreas Dilger, Theodore Ts'o and others");
 MODULE_DESCRIPTION("Fourth Extended Filesystem");
 MODULE_LICENSE("GPL");
--- a/fs/ext4/ialloc.c
+++ b/fs/ext4/ialloc.c
@@ -98,7 +98,7 @@ static unsigned ext4_init_inode_bitmap(s
  *
  * Return buffer_head of bitmap on success or NULL.
  */
-static struct buffer_head *
+struct buffer_head *
 ext4_read_inode_bitmap(struct super_block *sb, ext4_group_t block_group)
 {
 	struct ext4_group_desc *desc;
@@ -163,6 +163,7 @@ ext4_read_inode_bitmap(struct super_bloc
 	}
 	return bh;
 }
+EXPORT_SYMBOL(ext4_read_inode_bitmap);

 /*
  * NOTE! When we get the inode, we're the only people
