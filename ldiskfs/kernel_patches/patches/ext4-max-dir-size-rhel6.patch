Index: linux-stage/fs/ext4/super.c
===================================================================
--- linux-stage.orig/fs/ext4/super.c
+++ linux-stage/fs/ext4/super.c
@@ -999,6 +999,9 @@ static int ext4_show_options(struct seq_
 		seq_printf(seq, ",init_inode_table=%u",
 			   (unsigned) sbi->s_li_wait_mult);
 
+	if (sbi->s_max_dir_size)
+		seq_printf(seq, "max_dir_size=%lu", sbi->s_max_dir_size);
+
 	ext4_show_quota_options(seq, sb);
 
 	return 0;
@@ -1186,6 +1189,7 @@ enum {
 	Opt_mballoc, Opt_bigendian_extents, Opt_force_over_128tb,
 	Opt_discard, Opt_nodiscard,
 	Opt_init_inode_table, Opt_noinit_inode_table,
+	Opt_max_dir_size_kb,
 };
 
 static const match_table_t tokens = {
@@ -1263,6 +1267,7 @@ static const match_table_t tokens = {
 	{Opt_init_inode_table, "init_itable=%u"},
 	{Opt_init_inode_table, "init_itable"},
 	{Opt_noinit_inode_table, "noinit_itable"},
+	{Opt_max_dir_size_kb, "max_dir_size_kb=%u"},
 	{Opt_err, NULL},
 };
 
@@ -1648,6 +1653,12 @@ set_qf_format:
 		case Opt_nodelalloc:
 			clear_opt(sbi->s_mount_opt, DELALLOC);
 			break;
+		case Opt_max_dir_size_kb:
+			if (match_int(&args[0], &option))
+				return 0;
+			if (option < 0)
+				return 0;
+			sbi->s_max_dir_size = option * 1024;
 		case Opt_stripe:
 			if (match_int(&args[0], &option))
 				return 0;
@@ -2374,6 +2385,7 @@ EXT4_RO_ATTR(lifetime_write_kbytes);
 EXT4_ATTR_OFFSET(inode_readahead_blks, 0644, sbi_ui_show,
 		 inode_readahead_blks_store, s_inode_readahead_blks);
 EXT4_RW_ATTR_SBI_UI(inode_goal, s_inode_goal);
+EXT4_RW_ATTR_SBI_UI(max_dir_size, s_max_dir_size);
 EXT4_RW_ATTR_SBI_UI(mb_stats, s_mb_stats);
 EXT4_RW_ATTR_SBI_UI(mb_max_to_scan, s_mb_max_to_scan);
 EXT4_RW_ATTR_SBI_UI(mb_min_to_scan, s_mb_min_to_scan);
@@ -2389,6 +2401,7 @@ static struct attribute *ext4_attrs[] = 
 	ATTR_LIST(lifetime_write_kbytes),
 	ATTR_LIST(inode_readahead_blks),
 	ATTR_LIST(inode_goal),
+	ATTR_LIST(max_dir_size),
 	ATTR_LIST(mb_stats),
 	ATTR_LIST(mb_max_to_scan),
 	ATTR_LIST(mb_min_to_scan),
@@ -2884,6 +2897,7 @@ static int ext4_fill_super(struct super_
 	sbi->s_sb_block = sb_block;
 	sbi->s_sectors_written_start = part_stat_read(sb->s_bdev->bd_part,
 						      sectors[1]);
+	sbi->s_max_dir_size = 0;
 
 	unlock_kernel();
 
Index: linux-stage/fs/ext4/ext4.h
===================================================================
--- linux-stage.orig/fs/ext4/ext4.h
+++ linux-stage/fs/ext4/ext4.h
@@ -1114,6 +1114,7 @@ struct ext4_sb_info {
 	unsigned long s_mb_prealloc_table_size;
 	unsigned int s_mb_group_prealloc;
 	unsigned int s_max_writeback_mb_bump;
+	unsigned long s_max_dir_size;
 	/* where last allocation was done - for stream allocation */
 	unsigned long s_mb_last_group;
 	unsigned long s_mb_last_start;
Index: linux-stage/fs/ext4/namei.c
===================================================================
--- linux-stage.orig/fs/ext4/namei.c
+++ linux-stage/fs/ext4/namei.c
@@ -59,6 +59,14 @@ static struct buffer_head *ext4_append(h
 	* have to be serialized -bzzz */
 	down(&ei->i_append_sem);
 
+	if (unlikely(EXT4_SB(inode->i_sb)->s_max_dir_size &&
+		     (inode->i_size >=
+		     EXT4_SB(inode->i_sb)->s_max_dir_size))) {
+		*err = -ENOSPC;
+		up(&ei->i_append_sem);
+		return NULL;
+	}
+
 	*block = inode->i_size >> inode->i_sb->s_blocksize_bits;
 
 	bh = ext4_bread(handle, inode, *block, 1, err);
