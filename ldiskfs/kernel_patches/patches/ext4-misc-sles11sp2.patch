diff -ur linux-stage.orig/fs/ext4/ext4.h linux-stage/fs/ext4/ext4.h
--- linux-stage.orig/fs/ext4/ext4.h	2013-01-03 13:45:22.000000000 -0500
+++ linux-stage/fs/ext4/ext4.h	2013-01-08 11:40:58.000000000 -0500
@@ -1305,6 +1305,9 @@
 
 #define NEXT_ORPHAN(inode) EXT4_I(inode)->i_dtime
 
+/* Has been moved to linux/magic.h but we need it for Lustre */
+#define EXT4_SUPER_MAGIC	0xEF53
+
 /*
  * Codes for operating systems
  */
@@ -1823,6 +1826,9 @@
 				ext4_fsblk_t block, unsigned long count);
 extern int ext4_trim_fs(struct super_block *, struct fstrim_range *);
 
+extern void ext4_mb_discard_inode_preallocations(struct inode *);
+
+
 /* inode.c */
 struct buffer_head *ext4_getblk(handle_t *, struct inode *,
 						ext4_lblk_t, int, int *);
diff -ur linux-stage.orig/fs/ext4/ext4_extents.h linux-stage/fs/ext4/ext4_extents.h
--- linux-stage.orig/fs/ext4/ext4_extents.h	2013-01-03 13:45:22.000000000 -0500
+++ linux-stage/fs/ext4/ext4_extents.h	2013-01-08 11:40:58.000000000 -0500
@@ -58,6 +58,13 @@
  */
 #define EXT_STATS_
 
+/*
+ * define EXT4_ALLOC_NEEDED to 0 since block bitmap, group desc. and sb
+ * are now accounted in ext4_ext_calc_credits_for_insert()
+ */
+#define EXT4_ALLOC_NEEDED 0
+#define HAVE_EXT_PREPARE_CB_EXTENT
+#define HAVE_EXT4_EXT_PBLOCK
 
 /*
  * ext4_inode has i_block array (60 bytes total).
@@ -125,7 +134,7 @@
  * positive retcode - signal for ext4_ext_walk_space(), see below
  * callback must return valid extent (passed or newly created)
  */
-typedef int (*ext_prepare_callback)(struct inode *, ext4_lblk_t,
+typedef int (*ext_prepare_callback)(struct inode *, struct ext4_ext_path *,
 					struct ext4_ext_cache *,
 					struct ext4_extent *, void *);
 
@@ -287,6 +296,8 @@
 extern int ext4_ext_calc_credits_for_single_extent(struct inode *inode,
 						   int num,
 						   struct ext4_ext_path *path);
+extern int ext4_ext_calc_credits_for_insert(struct inode *,
+					    struct ext4_ext_path *);
 extern int ext4_can_extents_be_merged(struct inode *inode,
 				      struct ext4_extent *ex1,
 				      struct ext4_extent *ex2);
@@ -295,5 +306,14 @@
 							struct ext4_ext_path *);
 extern void ext4_ext_drop_refs(struct ext4_ext_path *);
 extern int ext4_ext_check_inode(struct inode *inode);
+extern int ext4_ext_search_right(struct inode *inode,
+				 struct ext4_ext_path *path,
+				 ext4_lblk_t *logical, ext4_fsblk_t *phys);
+extern int ext4_ext_search_left(struct inode *inode,
+				struct ext4_ext_path *path,
+				ext4_lblk_t *logical, ext4_fsblk_t *phys);
+extern int ext4_ext_walk_space(struct inode *inode, ext4_lblk_t block,
+				ext4_lblk_t num, ext_prepare_callback func,
+				void *cbdata);
 #endif /* _EXT4_EXTENTS */
 
diff -ur linux-stage.orig/fs/ext4/ext4_jbd2.c linux-stage/fs/ext4/ext4_jbd2.c
--- linux-stage.orig/fs/ext4/ext4_jbd2.c	2013-01-03 13:45:22.000000000 -0500
+++ linux-stage/fs/ext4/ext4_jbd2.c	2013-01-08 11:40:58.000000000 -0500
@@ -19,6 +19,7 @@
 	}
 	return err;
 }
+EXPORT_SYMBOL(__ext4_journal_get_write_access);
 
 /*
  * The ext4 forget function must perform a revoke if we are freeing data
@@ -150,3 +151,4 @@
 		sb->s_dirt = 1;
 	return err;
 }
+EXPORT_SYMBOL(__ext4_handle_dirty_metadata);
diff -ur linux-stage.orig/fs/ext4/ext4_jbd2.h linux-stage/fs/ext4/ext4_jbd2.h
--- linux-stage.orig/fs/ext4/ext4_jbd2.h	2013-01-03 13:45:22.000000000 -0500
+++ linux-stage/fs/ext4/ext4_jbd2.h	2013-01-08 11:40:58.000000000 -0500
@@ -35,6 +35,8 @@
 	(EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_EXTENTS)   \
 	 ? 27U : 8U)
 
+#define ext4_journal_dirty_metadata(handle, bh)  \
+		ext4_handle_dirty_metadata(handle, NULL, bh)
 /* Extended attribute operations touch at most two data buffers,
  * two bitmap buffers, and two group summaries, in addition to the inode
  * and the superblock, which are already accounted for. */
diff -ur linux-stage.orig/fs/ext4/extents.c linux-stage/fs/ext4/extents.c
--- linux-stage.orig/fs/ext4/extents.c	2013-01-03 13:45:22.000000000 -0500
+++ linux-stage/fs/ext4/extents.c	2013-01-08 11:40:58.000000000 -0500
@@ -1233,9 +1233,9 @@
  * returns 0 at @phys
  * return value contains 0 (success) or error code
  */
-static int ext4_ext_search_left(struct inode *inode,
-				struct ext4_ext_path *path,
-				ext4_lblk_t *logical, ext4_fsblk_t *phys)
+int ext4_ext_search_left(struct inode *inode,
+			 struct ext4_ext_path *path,
+			 ext4_lblk_t *logical, ext4_fsblk_t *phys)
 {
 	struct ext4_extent_idx *ix;
 	struct ext4_extent *ex;
@@ -1298,9 +1298,9 @@
  * returns 0 at @phys
  * return value contains 0 (success) or error code
  */
-static int ext4_ext_search_right(struct inode *inode,
-				 struct ext4_ext_path *path,
-				 ext4_lblk_t *logical, ext4_fsblk_t *phys)
+int ext4_ext_search_right(struct inode *inode,
+			  struct ext4_ext_path *path,
+			  ext4_lblk_t *logical, ext4_fsblk_t *phys)
 {
 	struct buffer_head *bh = NULL;
 	struct ext4_extent_header *eh;
@@ -1876,7 +1876,7 @@
 	return err;
 }
 
-static int ext4_ext_walk_space(struct inode *inode, ext4_lblk_t block,
+extern int ext4_ext_walk_space(struct inode *inode, ext4_lblk_t block,
 			       ext4_lblk_t num, ext_prepare_callback func,
 			       void *cbdata)
 {
@@ -1961,7 +1961,7 @@
 			err = -EIO;
 			break;
 		}
-		err = func(inode, next, &cbex, ex, cbdata);
+		err = func(inode, path, &cbex, ex, cbdata);
 		ext4_ext_drop_refs(path);
 
 		if (err < 0)
@@ -2202,6 +2202,55 @@
 }
 
 /*
+ * This routine returns max. credits extent tree can consume.
+ * It should be OK for low-performance paths like ->writepage()
+ * To allow many writing process to fit a single transaction,
+ * caller should calculate credits under truncate_mutex and
+ * pass actual path.
+ */
+int ext4_ext_calc_credits_for_insert(struct inode *inode,
+				     struct ext4_ext_path *path)
+{
+	int depth, needed;
+
+	if (path) {
+		/* probably there is space in leaf? */
+		depth = ext_depth(inode);
+		if (le16_to_cpu(path[depth].p_hdr->eh_entries)
+				< le16_to_cpu(path[depth].p_hdr->eh_max))
+			return 1;
+	}
+
+	/*
+	 * given 32bit logical block (4294967296 blocks), max. tree
+	 * can be 4 levels in depth -- 4 * 340^4 == 53453440000.
+	 * let's also add one more level for imbalance.
+	 */
+	depth = 5;
+
+	/* allocation of new data block(s) */
+	needed = 2;
+
+	/*
+	 * tree can be full, so it'd need to grow in depth:
+	 * we need one credit to modify old root, credits for
+	 * new root will be added in split accounting
+	 */
+	needed += 1;
+	/*
+	 * Index split can happen, we'd need:
+	 *    allocate intermediate indexes (bitmap + group)
+	 *  + change two blocks at each level, but root (already included)
+	 */
+	needed += (depth * 2) + (depth * 2);
+
+	/* any allocation modifies superblock */
+	needed += 1;
+
+	return needed;
+}
+
+/*
  * How many index/leaf blocks need to change/allocate to modify nrblocks?
  *
  * if nrblocks are fit in a single extent (chunk flag is 1), then
@@ -3919,13 +3968,14 @@
 /*
  * Callback function called for each extent to gather FIEMAP information.
  */
-static int ext4_ext_fiemap_cb(struct inode *inode, ext4_lblk_t next,
+static int ext4_ext_fiemap_cb(struct inode *inode, struct ext4_ext_path *path,
 		       struct ext4_ext_cache *newex, struct ext4_extent *ex,
 		       void *data)
 {
 	__u64	logical;
 	__u64	physical;
 	__u64	length;
+	loff_t	size;
 	__u32	flags = 0;
 	int		ret = 0;
 	struct fiemap_extent_info *fieinfo = data;
@@ -4107,7 +4157,8 @@
 	if (ex && ext4_ext_is_uninitialized(ex))
 		flags |= FIEMAP_EXTENT_UNWRITTEN;
 
-	if (next == EXT_MAX_BLOCKS)
+	size = i_size_read(inode);
+	if (logical + length >= size)
 		flags |= FIEMAP_EXTENT_LAST;
 
 	ret = fiemap_fill_next_extent(fieinfo, logical, physical,
@@ -4364,3 +4415,13 @@
 
 	return error;
 }
+
+EXPORT_SYMBOL(ext4_ext_search_right);
+EXPORT_SYMBOL(ext4_ext_search_left);
+EXPORT_SYMBOL(ext4_ext_insert_extent);
+EXPORT_SYMBOL(ext4_mb_new_blocks);
+EXPORT_SYMBOL(ext4_ext_calc_credits_for_insert);
+EXPORT_SYMBOL(ext4_mark_inode_dirty);
+EXPORT_SYMBOL(ext4_ext_walk_space);
+EXPORT_SYMBOL(ext4_ext_find_extent);
+EXPORT_SYMBOL(ext4_ext_drop_refs);
diff -ur linux-stage.orig/fs/ext4/inode.c linux-stage/fs/ext4/inode.c
--- linux-stage.orig/fs/ext4/inode.c	2013-01-03 13:45:22.000000000 -0500
+++ linux-stage/fs/ext4/inode.c	2013-01-08 11:40:58.000000000 -0500
@@ -5092,6 +5092,7 @@
 	iget_failed(inode);
 	return ERR_PTR(ret);
 }
+EXPORT_SYMBOL(ext4_iget);
 
 static int ext4_inode_blocks_set(handle_t *handle,
 				struct ext4_inode *raw_inode,
diff -ur linux-stage.orig/fs/ext4/mballoc.c linux-stage/fs/ext4/mballoc.c
--- linux-stage.orig/fs/ext4/mballoc.c	2013-01-03 13:45:22.000000000 -0500
+++ linux-stage/fs/ext4/mballoc.c	2013-01-08 11:40:58.000000000 -0500
@@ -4056,6 +4056,7 @@
 		call_rcu(&(pa)->u.pa_rcu, ext4_mb_pa_callback);
 	}
 }
+EXPORT_SYMBOL(ext4_discard_preallocations);
 
 #ifdef CONFIG_EXT4_DEBUG
 static void ext4_mb_show_ac(struct ext4_allocation_context *ac)
@@ -5178,3 +5179,6 @@
 
 	return ret;
 }
+
+EXPORT_SYMBOL(ext4_free_blocks);
+
diff -ur linux-stage.orig/fs/ext4/super.c linux-stage/fs/ext4/super.c
--- linux-stage.orig/fs/ext4/super.c	2013-01-03 13:45:22.000000000 -0500
+++ linux-stage/fs/ext4/super.c	2013-01-08 11:41:49.000000000 -0500
@@ -165,6 +165,7 @@
 		(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?
 		 (__u32)le16_to_cpu(bg->bg_itable_unused_hi) << 16 : 0);
 }
+EXPORT_SYMBOL(ext4_itable_unused_count);
 
 void ext4_block_bitmap_set(struct super_block *sb,
 			   struct ext4_group_desc *bg, ext4_fsblk_t blk)
@@ -1288,12 +1289,14 @@
 	Opt_data_err_abort, Opt_data_err_ignore,
 	Opt_usrjquota, Opt_grpjquota, Opt_offusrjquota, Opt_offgrpjquota,
 	Opt_jqfmt_vfsold, Opt_jqfmt_vfsv0, Opt_jqfmt_vfsv1, Opt_quota,
+	Opt_iopen, Opt_noiopen, Opt_iopen_nopriv,
 	Opt_noquota, Opt_ignore, Opt_barrier, Opt_nobarrier, Opt_err,
 	Opt_resize, Opt_usrquota, Opt_grpquota, Opt_i_version,
 	Opt_stripe, Opt_delalloc, Opt_nodelalloc, Opt_mblk_io_submit,
 	Opt_nomblk_io_submit, Opt_block_validity, Opt_noblock_validity,
 	Opt_inode_readahead_blks, Opt_journal_ioprio,
 	Opt_dioread_nolock, Opt_dioread_lock,
+	Opt_mballoc,
 	Opt_discard, Opt_nodiscard, Opt_init_itable, Opt_noinit_itable,
 };
 
@@ -1346,6 +1349,9 @@
 	{Opt_noquota, "noquota"},
 	{Opt_quota, "quota"},
 	{Opt_usrquota, "usrquota"},
+	{Opt_iopen, "iopen"},
+	{Opt_noiopen, "noiopen"},
+	{Opt_iopen_nopriv, "iopen_nopriv"},
 	{Opt_barrier, "barrier=%u"},
 	{Opt_barrier, "barrier"},
 	{Opt_nobarrier, "nobarrier"},
@@ -1365,6 +1371,7 @@
 	{Opt_noauto_da_alloc, "noauto_da_alloc"},
 	{Opt_dioread_nolock, "dioread_nolock"},
 	{Opt_dioread_lock, "dioread_lock"},
+	{Opt_mballoc, "mballoc"},
 	{Opt_discard, "discard"},
 	{Opt_nodiscard, "nodiscard"},
 	{Opt_init_itable, "init_itable=%u"},
@@ -1749,6 +1756,10 @@
 			else
 				clear_opt(sb, BARRIER);
 			break;
+		case Opt_iopen:
+		case Opt_noiopen:
+		case Opt_iopen_nopriv:
+			break;
 		case Opt_ignore:
 			break;
 		case Opt_resize:
@@ -1860,6 +1871,8 @@
 		case Opt_noinit_itable:
 			clear_opt(sb, INIT_INODE_TABLE);
 			break;
+		case Opt_mballoc:
+			break;
 		default:
 			ext4_msg(sb, KERN_ERR,
 			       "Unrecognized mount option \"%s\" "
