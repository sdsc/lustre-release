From 38a1101260a0fbb1e2de0f58487937dc57d32bd7 Mon Sep 17 00:00:00 2001
From: Wang Shilong <wshilong@ddn.com>
Date: Fri, 6 Mar 2015 09:54:28 +0800
Subject: [PATCH] ext4: try one more time with buffer locked

HongChao pointed that corrupted bitmap problem might because
some race problems,so before we really figured out everything.
If corrupt bitmaps are detected second time with buffer locked.
if second time pass but first time failed, we can make sure our
assumptions true.

Signed-off-by: Wang Shilong <wshilong@ddn.com>
---
 fs/ext4/balloc.c | 31 +++++++++++++++++++++++++++----
 1 file changed, 27 insertions(+), 4 deletions(-)

diff --git a/fs/ext4/balloc.c b/fs/ext4/balloc.c
index 61158ec..c4cb83d 100644
--- a/fs/ext4/balloc.c
+++ b/fs/ext4/balloc.c
@@ -237,7 +237,7 @@ static int ext4_valid_block_bitmap(struct super_block *sb,
 					struct buffer_head *bh)
 {
 	ext4_grpblk_t offset;
-	ext4_grpblk_t next_zero_bit;
+	ext4_grpblk_t next_zero_bit = 0;
 	ext4_fsblk_t bitmap_blk;
 	ext4_fsblk_t group_first_block;
 
@@ -275,10 +275,25 @@ static int ext4_valid_block_bitmap(struct super_block *sb,
 	if (next_zero_bit >= offset + EXT4_SB(sb)->s_itb_per_group)
 		/* good bitmap for inode tables */
 		return 1;
+	smp_mb();
+	next_zero_bit = ext4_find_next_zero_bit(bh->b_data,
+				offset + EXT4_SB(sb)->s_itb_per_group,
+				offset);
+	if (next_zero_bit >= offset + EXT4_SB(sb)->s_itb_per_group) {
+		ext4_warning(sb, "Second time validate next zero bit passed");
+		return 1;
+	}
 
 err_out:
-	ext4_error(sb, "Invalid block bitmap - block_group = %d, block = %llu",
-			block_group, bitmap_blk);
+	ext4_error(sb, "Invalid block bitmap - group_first_block = %llu, "
+			"block_bitmap = %llu, inode_bitmap = %llu "
+			"inode_table_bitmap = %llu, "
+			"inode_table_block_per_group =%ld, "
+			"next_zero_bit = %llu, block_group = %d, block = %llu",
+			group_first_block, ext4_block_bitmap(sb, desc),
+			ext4_inode_bitmap(sb, desc), ext4_inode_table(sb, desc),
+			EXT4_SB(sb)->s_itb_per_group, (unsigned long long)next_zero_bit,
+			block_group, (unsigned long long)bitmap_blk);
 	return 0;
 }
 /**
@@ -297,6 +312,7 @@ ext4_read_block_bitmap(struct super_block *sb, ext4_group_t block_group)
 	struct ext4_group_desc *desc;
 	struct buffer_head *bh = NULL;
 	ext4_fsblk_t bitmap_blk;
+	int ret;
 
 	desc = ext4_get_group_desc(sb, block_group, NULL);
 	if (!desc)
@@ -351,7 +367,14 @@ ext4_read_block_bitmap(struct super_block *sb, ext4_group_t block_group)
 			    block_group, bitmap_blk);
 		return NULL;
 	}
-	ext4_valid_block_bitmap(sb, desc, block_group, bh);
+	ret = ext4_valid_block_bitmap(sb, desc, block_group, bh);
+	if (!ret) {
+		lock_buffer(bh);
+		ret = ext4_valid_block_bitmap(sb, desc, block_group, bh);
+		unlock_buffer(bh);
+		if (ret)
+			ext4_warning(sb, "second call ext4_valid_block_bitmap passed");
+	}
 	/*
 	 * file system mounted not to panic on error,
 	 * continue with corrupt bitmap
-- 
1.8.2.1

